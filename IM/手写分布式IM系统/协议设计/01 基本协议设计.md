协议设计是IM的核心工作，这一设计将对IM的整体架构产生决定性作用。
## 设计目标
IM的核心场景是A客户端发送上行消息给到服务器，服务器发送下行消息给到B客户端。

>可达有序，不重不漏=【QoS2+时序性】
	1.消息要及时可达。
	2.消息不能遗漏和重复。
	3.保证消息时序性：展示在接收端的消息必须保证是按发送时间排序的。

## 评估标准
1. 【性能】协议传输效率，尽可能的降低端到端延迟。
2. 【兼容】既要向前兼容也要向后兼容。
3. 【存储】减少消息包的大小，降低空间占用率。
4. 【计算】减少编解码时造成的CPU使用率的权衡。
5. 【网络】尽可能的减少网络带宽消耗。
6. 【安全】协议安全性，防止协议被破解。
7. 【选代】尽可能的灵活扩展，支持IM复杂业务的演进。
8. 【通用】可跨平台接入，H5，客户端，loT设备。
9. 【可读】易于理解，方便调试。
## 基本结构
IM协议的设计从纵向看，可以考虑三个层次，应用层/安全层/传输层。

| 应用层 | 文本协议：可读性好，性能低。<br>二进制协议：可读性差，难以调试，性能高，业界无可争议的使用protobuf<br>![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/124476c71ea9a92716ed30dbf3c25006_MD5.jpeg)                                                                                                                                                                                                                                                   | ![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/569437c872745a6c38afd8e144dfd74c_MD5.jpeg)<br>![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/51fb2f97d30edba4c668b8c4861d9cf1_MD5.jpeg) |
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 安全层 | **基于密钥的生命周期**可以划分为：<br>1. **TLS/SSL**：加密效果好，但证书管理相对复杂。<br>2. **固定加密**：通信前客户端和服务端约定好密钥和加密算法。<br>3. **一人一密**：在通信前客户端先向服务端请求密钥，服务端会用用户特有属性生成密钥下发下去，然后进行加密通信。<br>4. **一次一密**：创建连接建立一次会话时，双方进行加密三次握手，使用非对称加密握手，对称加密传输，参考SSL握手过程。<br>**加密消耗cpu计算资源，安全性也要考虑消息在服务端存储的安全性和合规性要求，要做出取舍。**<br>网关对数据包进行TLS3.0协议的密钥协商握手，加解密操作，这会消耗大量CPU，所以对于加解密操作可以使用GPU。<br>参考：[通俗易懂：一篇掌握即时通讯的消息传输安全原理-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-970-1-1.html) | TLS3.0协议+网关终止<br>![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/b0f6633a90f3b19883de06ab0279b205_MD5.jpeg)                                                                                                                   |
| 传输层 | TCP：面向连接的可靠传输协议，仅能保证数据到达传输层，维护状态消耗资源，网络不稳定时频繁重连性能差。<br>UDP：无状态的传输协议，弱网环境更优。<br>阅读： [网络编程懒人入门(十)：一泡尿的时间，快速读懂QUIC协议-网络编程/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/forum.php?mod=viewthread&tid=2816&highlight=quic)<br>![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/bdb38aec751cac34bb39def250244d50_MD5.jpeg)                                                                                          | TCP保证数据可靠传输到服务器，减少复杂度，使用epoll技术以及应用层设计，可以克服有状态链接的弊端。                                                                                                                                                                                                               |
## 开源协议
> 结论：如果团队小，团队技术在IM上积累不够多可以考虑便用XMPP或者MQTT+HTTP短连接的实现。
> 反之可以考虑自已设计和实现私有协议+Protobuf

| 名称         | 特性                                                                                                                                                                                                                                                                                                                                                                                                  | 取舍                                                                                                                                                                                   |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| IMPP       | 1. RFC2798 \| RFC2799<br>2. 这是一个协议标准，没有具体实现<br>3. 其中涉及的角色具有参考意义，是非常通用的设计                                                                                                                                                                                                                                                                                                                            | 1. 太过抽象/通用，可读性差。<br>取舍<br>2. **仅是一个模型**，跟自研没什么区别。                                                                                                                                    |
| XMPP       | 1. 一种基于XML的应用层协议<br>2. XML可以跨平台，跨IM服务传输<br>3. 适用于一些邮箱应用如Spark（不是大数据那个）                                                                                                                                                                                                                                                                                                                              | 1. 文本协议性能差，信息穴余压缩率低<br>2. 解析dom极耗时，**性能极差** <br>3. **难以保证消息可靠性QoS**                                                                                                                  |
| SIMPLE     | 1. SIP协议RFC，应用于流媒体，音视频场景，这是对其的扩展<br>2. 针对IM聊天场景的扩展，是应用层文本协                                                                                                                                                                                                                                                                                                                                          | 1. 文本协议，压缩率低，**占用网络带宽**<br>2. 没有找到直接相关的SIMPLE，SIP/SDP都需要较大改造成本<br>3. **不满足性能与可选代性** <br>4. **难以保证消息可靠性QoS**                                                                          |
| MQTT       | 1. 异步通信，消息报文简单，适合推送场景<br>2. 轻量级发布订阅模式，一对多的分发模式，资源消耗也很少<br>3. 代码少，可以在多种单片机上轻松实现 <br>4. 支持QoS(0-2)<br>5. 适用于设备的存储和网络带宽有限的物联网场景<br>6. 阅读：[IBM技术经理访谈：MQTT协议的制定历程、发展现状等-推送开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/forum.php?mod=viewthread&tid=525&highlight=mqtt)<br>![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/7413bb692f54c609ef59af750c1a2481_MD5.jpeg) | 1. 需要增加可变头并做一些改进，才能支持时序性 <br>2. 基于IM需求定制化开发的场景很多，**扩展性差**                                                                                                                            |
| WebSocket  | 1. 客户端和服务端仅需要一次握手就可以创建链接<br>2. 使用简单，支持全双工，各大浏览器均支持，多用于H5 <br>3. 复用HTTP通道，在HTTP基础上进行协议升级<br>4. 基于数据顿格式进行传输 <br>5. 阅读：[理论联系实际：从零理解WebSocket的通信原理、协议格式、安全性-网页端IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/forum.php?mod=viewthread&tid=1341&highlight=%C0%ED%C2%DB%C1%AA%CF%B5%CA%B5%BC%CA)                                                                                                           | 1. 需要业务自己保证消息时序性<br>2. 需要业务处理**断线重连**等场景，**扩展性弱**<br>3. 建立长链接时，需要通过HTTP协议升级，建立和重连都很慢<br>4. 数据顿格式定制化能力较差，信息有穴余。 <br>5. 原生客户端难以扩展，协议库需要二次开发。<br>6. websocket的协议还是字符流协议，**信息压缩率差**，浪费带宽 |
| 自研二进制协议    | 1. 几乎主流IMAPP公司都这么做。 <br>2. 灵活/高效/难以破解。                                                                                                                                                                                                                                                                                                                                                              | 1.**通用性差**，不易扩展。<br>2.需要手写字节流处理逻辑，容易出错，**迭代效率低**。                                                                                                                                    |
| 私有协议+开源序列化 | 1. 克服了自研二进制协议的通用性和维护性的问题<br>2. 阅读：[Protobuf通信协议详解：代码演示、详细原理介绍等-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/forum.php?mod=viewthread&tid=323&highlight=protobuf%CD%A8%D0%C5%D0%AD%D2%E9%CF%EA%BD%E2)                                                                                                                                                                                                | **完美**                                                                                                                                                                               |
## plato协议
对于传输层，我们选择**TCP协议**，安全层选择**TLS协议**，应用层选择**自研二进制协议+开源序列化协议** 
1. TCP协议保障了消息可靠的传送到网关服务上，相对于UDP来说少处理很多bad case，简化开发成本，同时可以通过在业务层实现**断线重连等弱网优化手段，来应对弱网环境TCP频紧断的情况。**
2. TLS3.0协议，优化了握手的速度提升了性能，同时可以较好的兼性能和安全性是一个高性价比进择，但是如果在gateway server上实现，由于TLS的握手/加解密都是cpu密集型操作，极端情况下会拉高gatewayserver的cpu使用率使其造成性能抖动，为此我们选择在L7层负载均衡器上实现**TLS终止**，使用L7层负载均衡器会增加一跳的数据包的转发这会造成性能损耗，不过可以使用TLS加速卡（因特尔QAT）等硬件加速技术解决，对于IM场景，如果仅考虑性能的话，也可以在L4层负载均器上实现 TLS终止，去掉L7层负载均衡器，直接IP路由到gateway server。
3. 对于应用层一个简单灵活的二进制协议实现可以分为固定消息头，变长消息头，消息体三部分。
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/01fb0a7888edb29ce6b495f04c556993_MD5.jpeg)
## 编码器伪代码
``` go
type Message struct {
	fixedHeader *FixedHeader
	varHeader PBData
	msgBody PBData
}
func(msg *Message)Encoder []byte {
	buf:=make([]byte,14)
	buf[0] = msg.fixedHeader.Version
	buf[1] = msg.fixedHeader.msgType
	copy(buf[2:6]，uint32ToBytes(msg.fixedHeader.MsgLen))
	copy(buf[6:10],uint32ToBytes(msg.fixedHeader.varHeadLen))
	copy(buf[10:14],uint32ToBytes(msg.fixedHeader.crc32Sum))
	buf = append(buf, msg.varHeader.Bytes()) 
	buf = append(buf, msg.msgBodey.Bytes())
	return buf
}
func send(data []byte){
	sock.Send(data)
	...
}
```
## 解码器伪代码
> 阅读：[# TCP的粘包、拆包以及解决方案](https://zhuanlan.zhihu.com/p/356225028)

TCP是基于字节流的传输协议，因此并没有物理上的消息边界，这造成数据包传输过程中存在如下情况：
假设，发送防发送了两个数据包p1和p2，则有 
1. p1的部分数据发送到接收端
2. p1的后半部分数据和p2的前半段数据一起发送到接收端
3. p2的后半段数据发送到接收端 
4. p1和p2合并到一起发送到接收端
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/d43f759275e37d1cb63b2a2f21681e11_MD5.jpeg)
``` go
// 从无尽的流中解码数据
func Accept() {
	buf := make([byte,14) 
	for conn.Read(buf) {
		msg := &Message{}
		msg.fixedHeader.version = buf[0]
		msg.fixedHeader.msgType = buf[1]
		msg.fixedHeader.msgLen = bytesTouint32(buf[2:6])
		msg.fixedHeader.varHeadLen = bytesTouint32(buf[6:10])
		msg.fixedHeader.crc3sum = bytesTouint32(buf[10:14])
		varHeadBuf := make([]byte, msg.FixedHeader.varHeadLen)
		conn.Read(varHeadBuf)
		msg.varHeader=pb.Data(varHeadBuf)
		bodyBuf := make([]byte, msg.FixedHeader.MsgLen)
		conn.Read(bodyBuf)
		msg.msgBody = pb.Data(bodyBuf) 
		header.Pool(msg)
	}
}
```
## 思考
基于plato这个基本协议，如何保证消息的可靠性？**可达有序，不重不漏。**