## 前置阅读
1. [零基础IM开发入门(四)：什么是IM系统的消息时序一致性？-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/forum.php?mod=viewthread&tid=3189&highlight=%CA%B2%C3%B4%CA%C7IM%CF%B5%CD%B3%B5%C4%CF%FB%CF%A2%CA%B1%D0%F2%D2%BB%D6%C2%D0%D4%A3%BF)
2. [长连接和短链接的区别 - 简书](https://www.jianshu.com/p/e77fdb9bace3)
3. [理解IM消息“可靠性”和“一致性”问题，以及解决方案探讨-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-3574-1-1.html)
4. [IM消息送达保证机制实现(一)：保证在线实时消息的可靠投递-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-294-1-1.html)
5. [如何保证IM实时消息的“时序性”与“一致性”？-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-714-1-1.html)
6. [IM消息ID技术专题(一)：微信的海量IM聊天消息序列号生成实践（算法原理篇）-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-1998-1-1.html)
7. [IM消息ID技术专题(二)：微信的海量IM聊天消息序列号生成实践（容灾方案篇）-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-1999-1-1.html)
8. [IM消息ID技术专题(三)：解密融云IM产品的聊天消息ID生成策略-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/forum.php?mod=viewthread&tid=2747)
9. [IM消息ID技术专题(四)：深度解密美团的分布式ID生成算法-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-2751-1-1.html)
10. [IM消息ID技术专题(五)：开源分布式ID生成器UidGenerator的技术实现-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-2953-1-1.html)
11. [IM消息ID技术专题(六)：深度解密滴滴的高性能ID生成器(Tinyid)-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-3129-1-1.html)
## 基本概念
**长链接 vs 短链接**
1. connID / clientID / seqID / sessionID / msgID
2. PULL 与 PUSH 模式
3. 通信复杂度-消息风暴
可靠性：可达、不漏（重发机制、会话记录检查）
一致性：有序、不重（uuid去重、向量时钟消息排序）

> 一种可能的实现思路是：对于 IM 系统消息可靠性及一致性问题，通过消息重发机制保证消息成功被服务端接收，通过会话记录检查保证收取消息完整，从而保证整个消息发送过程的可靠性。使用 uuid 消息去重，参考向量时钟算法进行消息排序，为保证消息一致性提供一种解决方案

---
有关向量时钟参考：
1. [Site Unreachable](https://zhuanlan.zhihu.com/p/56146800)
2. [Site Unreachable](https://zhuanlan.zhihu.com/p/56886156)
## 背景介绍
可靠性：消息一旦显示发送成功就必定送达到对端，一致性：任意时刻消息保证与发送端顺序一致。
消息可靠与一致对于IM来说，就是指：**可达有序，不重不漏**
设计IM必须具有端到端的设计思维（[端对端原则的思考及反思-CSDN博客](https://blog.csdn.net/do_best_/article/details/79755904)），底层对可靠性的保证仅能保证底层的可靠，而不能保证上层的可靠，底层的可靠仅是减小了发生故障的概率：**底层可靠不等于上层可靠，同理：底层一致不等于上层一致**
>消息的端到端可靠性 =上行消息可靠 + 服务端业务可靠 +下行消息可靠
>消息的端到端一致性 =上行消息一致 + 服务端业务一致 +下行消息一致

为论述方便，下文中提到的==消息可用==指的是==IM消息可用性==，包含消息可靠性和一致性两个方面。
***
TCP究竟帮助我们做到哪一步？
1. 客户端A发送msg1和msg2两入消息给到服务端。
2. msg1和msg2在一个tcp链接上到达服务端。
问题
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/a24ba6166bd2069f64f264e5eb6456b9_MD5.jpeg)
	1. 在传递给业务层时服务端进程崩溃，但容户端A认为经送达，服务端业务层无感知因此消息丢失。
	2. msg1和msg2到达应用层，解析后交由两个线程处理，msg2先落表并先发给客户端B,造成消息乱序。
	3. msg1消息存储失败，msg2消息存诸成功先发送给了客户端B，造成丢失且乱序
> 洞见：TCP/IP是双方通信，而IM本质上是三方通信

设计目标
> 1. 设计一个能够保证消息端到端可用性的协议。
> 2. 满足目基本协议中的协议评估标准。

技术挑战在哪里？
1. 三方通信，网络层面无法保证消息必达
2. 没有全局时钟，确定唯一顺序，且是符合因果顺序的
3. 多客户端发送消息 / 多服务端接收消息 / 多线程多协程处理消息，顺序难以确定
## 方案选型
> 及时性,可达性,等性,时序性

1. **消息及时**：服务端实时接收消息并实时在线发送
2. **消息可达**：超时重试，ACK确认
3. **消息幕等**：分配seqID，服务端存储seqID
4. **消息有序**：seqID可比较，接收端能按发送端的顺序对消息排序
> 消息在会话内有序即可
### 上行消息
>客户端A将消息发送给服务端，这一阶段要保证消息从客户端到服务端的可用性

| 方案                                                                                                                                                                                                                                                                                  | 收益                                                                                             | 代价                                                                           |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| ==clientID 严格递增==<br>1. 客户端A创建会话与服务端建立长连接<br>2. 在发送消息msg1时分配一个clientID此值在会话内**严格递增**<br>3. 连接建立时 clientID初始为0<br>4. 服务端将上一次收到消息的clientID缓存为preClientID，当且仅当<br>clientID  == preclientID + 1 时接收此消息<br>5. 仅当服务端接收到消息后才回复客户端A，ACK消息<br>6. 仅当客户端A收到服务端对消息ACK的回复，才禁止重发(可设置最大三次）<br><br> | 1. 任意时刻仅存储一个消息ID<br>2. 保证严格的有序性<br>3. 实现简单，**可用**<br> 4. 长连接通信延迟低<br> 5. **以发送方顺序为标准（权衡）**<br> | 1. 弱网情况下，消息丢包严重时将造成大规模消息重发，导致网络瘫痪影响消息及时性<br>2. **无法保证群聊中的消息因果顺序**            |
| 弱网问题，可以通过优化传输层协议(比如协议升级为Quic)来优化，长连接不适合在弱网环境工作，丢包和断线属于传输层问题                                                                                                                                                                                                                         |                                                                                                |                                                                              |
| ==clientID 链表==<br>1. 客户端A使用本地时间戳作为clientID，并在每次发送消息的时候携带上个消息的clientID<br>2. 服务端存储上一个消息的clientID记作为preClientID，只有preClientID和当前消息的preClientID对比，匹配上则说明消息未丢失，否则拒绝                                                                                                                    |                                                                                                | 1. 协议的消息带宽                                                                   |
| ==clientID list==<br>1. 服务端针对每个连接存储多个clientID，形成clientID list<br>2. 使用此 client List作为滑动窗口，来保证消息幕等                                                                                                                                                                                   | 1. 减少弱网重传时的消息风暴问题                                                                              | 1. 实现更为复杂<br>2. 网关层需要更多的内存维护连接状态<br>3. 由于传输层使用tcp，已经对弱网有一定的优化，应用层也维护滑动窗口收益不大 |
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/d51bae1912c995bf6fcc1ea581f63b39_MD5.jpeg)
### 消息转发
> 分配seqID，异步存储消息，处理业务逻辑，将消息转发给客户端B

为什么要分配seqID？
> IM场景中聊天会话至少有两个客户端参与（单聊/群聊），因此任何一人客户端分配的clientID都不能作为整个会话内的消息ID，否则会产生顺序冲突，因此clientID仅是保证消息按客户端A发送的顺序到达服务端，服务端需要在整个会话范围内分配一个全局递增的ID。

==事实上仅需要保证同一个客户发送消息的先后顺序即可==
消息转发的可用性如何保证？

| 方案                                                                                                                                                                                                                            | 收益                                                 | 代价                                                         |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- | ---------------------------------------------------------- |
| 如果服务端在分配seqID前此请求失败或进程崩溃怎么办？<br>**服务端在分配seqID之后再回复ACK消息。**                                                                                                                                                                    | 保证了分配seqID消息的可用性                                   | 1. ack回复变慢,收发消息变慢<br>2. 如果消息存储失败消息将丢失<br>3. seqID 分配成为性能瓶颈 |
| 如果服务端在存储消息，业务处理，接入层路由时失败怎么办？<br>1. **消息存储后再回复ACK，如果ACK失败则客户端重试时再次幂等地回复ACK**<br>2. 一旦消息存储，如果服务崩溃导致长连接断开，客户端重新建立连接时可以发送一个pull信令，拉取历史消息进行消息补洞，以此保证消息可用性<br>3. 如果消息存储后，仅是业务层失败，接入层长连接无感知，业务层需要做异常捕获，并追加pull信令请求给到客户端B，主动触发其拉取历史消息 | 1. 保证了业务处理全流程的可用性<br>2. 在出现异常情况时，可毫秒级触发接收端，保证消息及时性 | 1. 上行消息的p95延迟将增加<br>2. 整体通信复杂度增高<br>3. 应对弱网环境需要协议升降级机制     |
| 可以将消息交给MQ异步存储，MQ来保证消息不丢失                                                                                                                                                                                                      | 异步写入，优化了p95延迟                                      |                                                            |
| seqID无需全局有序，仅保证在会话内有序即可                                                                                                                                                                                                       | 解决了seqID分配的单点瓶颈                                    |                                                            |
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/60f6a7d513b005f30284987c0d6826af_MD5.jpeg)
### 下行消息
> 服务端将消息发送给客户端B，其协议设计依赖于seqID的生成方式

| 方案                                                                                                                                                                                                                                                                                                              | 收益                                                                                                                        | 代价                                                                                        |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| 客户端定期轮询发起pull请求拿到新消息                                                                                                                                                                                                                                                                                            | 实现简单，保证可用性                                                                                                                | 1. 客户端耗电高(用户体验差)<br>2. 消息时延高，不满足及时性                                                       |
| 依赖seqID的**严格递增**<br>1. 用redis incrby 生成seqID，key是sessionID/connID<br>2. 按消息到达服务端的顺序分配seqID，使其具有会话范围内的全局序<br>3. 服务端保证seqID严格递增的前提下将消息发送给客户端B，客户端B也是按`preSeqID == seqID + 1`的方式来做到幂等                                                                                                                              | 1. 实现简单，可以快速上线<br>2. 最大程度的保证**严格递增**                                                                                      | 1. 弱网重传问题<br>2. Redis 存在单点问题，难以保证严格递增<br>3. 需要维护超时重传消息队列以及定时器<br>4. **不能解决客户端B不在线时消息的传递** |
| 应对redis的单点故障，seqID的**趋势递增**<br>1. 使用lua脚本，存储maxSeqID以及当前的node的runID<br>2. lua脚本每次获取ID时，都会检查当前node的runID和存储的runID是否一致<br>3. 发现不一致时，说明发生了主从切换，然后对maxSeqID进行一次跳变保证递增，避免从节点由于同步数据不及时分配了一个曾经分配过的ID出去<br>4. 客户端B在发现消息不连续时不是直接拒绝，而是发送pull信令进行增补<br>5. 如果拉取不到新消息，则说明是seqID的跳变导致，不再进一步处理<br>6. 如果客户端B不在线，查询用户状态后仅存储不推送即可 | 1. 尽最大可能保证连续性<br>2. 任意时刻保证单调和递增性<br>3. 由于使用会话级别的seqID，则不需要全局分布式ID生成，redis可以使用cluster模式进行水平扩展<br>4. 识别了用户是否在线的状态，减少了网络带宽消耗 | 1. 协议交互变得更加复杂，实现难度上升<br>2. 可评估用户规模进行决策是否支持如此级别的可用性<br>3. 群聊场景，将造成消息风暴                     |
| 推拉结合+服务端打包整流                                                                                                                                                                                                                                                                                                    | 解决消息风暴问题                                                                                                                  | 实现更加复杂                                                                                    |
| SeqID 链表<br>1. 客户端B在本地存储最后接收到的seqID的值记作maxSeqID<br>2. 服务端发送消息时，携带上一条消息的seqID记作preSeqID和当前seqID<br>3. 客户端B接收消息时通过对比maxSeqID == preSeqID 则接收否则拒绝<br>4. 服务端在设计消息存储时，要存储上一条消息的seqID，形成逻辑链表<br>5. 客户端发现preSeqID不一致，则退化为pull请求去拉缺失的消息                                                                                 | 1. 屏蔽了对seqID 趋势递增的依赖                                                                                                      | 1. 收益不大，且在消息存储时要多一个preSeqID                                                               |
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/9143c3638ecac35702e36977467d0eb6_MD5.jpeg)
## plato的v1.0.0方案
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/223401a6daff761e54c4e0546f280e24_MD5.jpeg)
1. 客户端A创建连接后，分配一个clientID，从0开始即可，发送一人消息时获得clientID并自增
2. 启动一个消息计时器，等待ack消息的回复，或者超时后触发重传
3. 基于tcp连接将msg1发送给服务端
4. 服务端请求redis使用sessionID进行分片，incryBy获得seqID
5. 异步写入MQ，保证消息可靠存储
6. 立即回复客户端A ack消息，告诉他消息已经可靠送达
7. 启动一个下行消息定时器，等等客户端B的ack消息，或者超时后触发重传
8. 客户端A收到ack消息后，取消定时器
9. 服务端发起下行消息请求，将msg1发送给客户端B
10. 客户端B根据当前session的maxSeqID+1是否等于当前消息的seqID来决定是否接收
11. 客户端B回复服务端消息已经确认或者拒绝
12. 服务端根据客户端B回复决定是进行消息补洞还是关闭定时器
## Plato协议
### 基础消息协议
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/c223ae2a59b07e3f9fdcbaec5570af64_MD5.jpeg)
### v1.0.0 端到端可用的消息协议
1. 信令：`msgType = UplinkMessage`
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/54b949167e315f7e886b6db6f0a71d0f_MD5.jpeg)
2. 信令：`msgType = DownlinkMessage`
![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/attachments/7ade8d781329c3ebb6985fbca04dca32_MD5.jpeg)

## 拓展资料
1. [IM群聊消息如此复杂，如何保证不丢不重？-IM开发/专项技术区 - 即时通讯开发者社区!](http://www.52im.net/thread-753-1-1.html)
2. [细聊分布式ID生成方法](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=403837240&idx=1&sn=ae9f2bf0cc5b0f68f9a2213485313127&scene=21#wechat_redirect)
---
## 生产环境下时序性以及一致性的优化方法
1. 客户端或服务端时序为准
2. 服务端能够生成单调递增的id
3. 误差不大的趋势递增id
4. 单点序列化
5. IM中单聊怎么保证发送顺序与接受顺序一致？消息中添加发送方的本地时序
6. IM中群聊场景，如何保证各个接收方收到的顺序一致？使用服务器的单点做序列化，生成seq；
7. 6中单点递增序列号服务容易成为系统瓶颈，事实上，群聊消息不用保证全局消息的一致性，只需要保证一个群内的消息有序即可，可以使用id串行化。