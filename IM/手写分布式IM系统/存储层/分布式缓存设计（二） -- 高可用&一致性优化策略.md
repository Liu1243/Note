### 4. 高可用 5个9，5min内修复问题

| 方案                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 收益                  | 代价                                                                                                      |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | ------------------------------------------------------------------------------------------------------- |
| ==缓存穿透==<br>缓存穿透强调的是查询不存在的key，对于不存在的key旁路缓存等设计模式，必然会打到DB查询，对于空key的查询将导致缓存失效 <br>1. 空保护，在缓存中增加对空key的缓存，通常TTL设置的较短，以保证一致性。<br>2. 布隆过滤器，bf假阳性对不存在的key判断是一定正确的，这说明bf可以有效防止空key查询，同时对空间的占用最小。<br>由于消息状态变化的很快，要求实时性，而构建bf需要离线构建，难以在线化bf算法，使其并不适用此场景<br>因此plato选择在缓存中，缓存5s的空key来防止缓存穿透现象。<br>![](IM/%E6%89%8B%E5%86%99%E5%88%86%E5%B8%83%E5%BC%8FIM%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%B1%82/attachments/ba5bbdff0c77f6dc7ad27f3abe15a1de_MD5.jpeg)                                                                                                                                                               | 解决了缓存击穿问题，系统可用性得到提升 | 1. 增加了一定的缓存成本，如果调用者大量查询空key，导致缓存过多空key、却将有效的key淘汰，则将造成系统命中率下降。<br>2. 同时如果存在scan等查询改变了缓存的热度分布，也会导致命中率降低。 |
| ==缓存击穿==<br>大量的key同时失效，热key失效，缓存节点崩溃重后启，等情况都会导致在某个瞬间缓存失效，DB被大量访问。 <br>1. 针对天量的key同时过期问题，在ttl上加入随机时间截<br>2. 针对缓存节点崩渍问题，可以增加缓存预热环节（cdn）,当命中率达到一定程度后才能对外提供服务<br>3. 数据库也可以做限流管理，介入MQ，或者通过数据库代理来做限流，过载保护机制。 <br>4. 可以使用分布式锁来解决旁路缓存更新时由于刷除key造成的击穿情况（**租约机制**）<br>a.<br>删除key的同时，由于setkey并非原子操作，此时就会存在被大量QPS击穿DB的情况<br>8<br>b.<br>解决办法就是使用分布式锁，最先读取的线程发现其key为空，则同时set一个时间截作为锁（租约机制)，过期后自动释放<br>其他线程查询时发现此为处key是一个时间载则认为有锁进行自旋 c.<br>最先读取的线程将DB的数据回写到此key处，对覆盖之前的时间截完成锁的释放 d.<br>e.读空key后写入一个时间戳截的操作需要使用lua脚本实现(或者使用其他支持原子事务的kv) f.<br>除时间截外，还需要一个标记当前读线程的id，用来作为锁标记，防正多个线程同时释放锁，造成踝露。<br>Plato对消息状态的更新可以使用此种办法防止缓存击穿。 |                     |                                                                                                         |
