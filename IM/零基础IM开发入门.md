参考： http://www.52im.net/thread-3065-1-1.html
**目录**

- [1. 什么是IM系统](#1.%20%E4%BB%80%E4%B9%88%E6%98%AFIM%E7%B3%BB%E7%BB%9F)
	- [1.1 IM的应用场景](#1.1%20IM%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
	- [1.2 IM的典型架构](#1.2%20IM%E7%9A%84%E5%85%B8%E5%9E%8B%E6%9E%B6%E6%9E%84)
	- [1.3 IM技术的特点](#1.3%20IM%E6%8A%80%E6%9C%AF%E7%9A%84%E7%89%B9%E7%82%B9)
	- [1.4 IM的功能组成](#1.4%20IM%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BB%84%E6%88%90)
		- [1）联系人列表](#1%EF%BC%89%E8%81%94%E7%B3%BB%E4%BA%BA%E5%88%97%E8%A1%A8)
		- [2）聊天界面](#2%EF%BC%89%E8%81%8A%E5%A4%A9%E7%95%8C%E9%9D%A2)
		- [3）消息发送通道](#3%EF%BC%89%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%80%9A%E9%81%93)
		- [4）消息接收通道](#4%EF%BC%89%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E9%80%9A%E9%81%93)
		- [5）消息存储](#5%EF%BC%89%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8)
		- [6）消息未读数](#6%EF%BC%89%E6%B6%88%E6%81%AF%E6%9C%AA%E8%AF%BB%E6%95%B0)
- [2. 什么是IM系统的实时性](#2.%20%E4%BB%80%E4%B9%88%E6%98%AFIM%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E6%97%B6%E6%80%A7)
	- [2.1 短轮询技术](#2.1%20%E7%9F%AD%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF)
	- [2.2 长轮询技术](#2.2%20%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF)
	- [2.3 轮询无法实现真正的“实时性”](#2.3%20%E8%BD%AE%E8%AF%A2%E6%97%A0%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9C%9F%E6%AD%A3%E7%9A%84%E2%80%9C%E5%AE%9E%E6%97%B6%E6%80%A7%E2%80%9D)
	- [2.4 WebSocket让Web端IM真正的“实时性”变成可能](#2.4%20WebSocket%E8%AE%A9Web%E7%AB%AFIM%E7%9C%9F%E6%AD%A3%E7%9A%84%E2%80%9C%E5%AE%9E%E6%97%B6%E6%80%A7%E2%80%9D%E5%8F%98%E6%88%90%E5%8F%AF%E8%83%BD)
- [3. 什么是IM系统的可靠性](#3.%20%E4%BB%80%E4%B9%88%E6%98%AFIM%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7)
	- [3.1 典型的在线消息收发流程](#3.1%20%E5%85%B8%E5%9E%8B%E7%9A%84%E5%9C%A8%E7%BA%BF%E6%B6%88%E6%81%AF%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B)
	- [3.2 TCP不能保证在线消息的“可靠性”](#3.2%20TCP%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%9C%A8%E7%BA%BF%E6%B6%88%E6%81%AF%E7%9A%84%E2%80%9C%E5%8F%AF%E9%9D%A0%E6%80%A7%E2%80%9D)
	- [3.3 为在线消息增加“可靠性保证”](#3.3%20%E4%B8%BA%E5%9C%A8%E7%BA%BF%E6%B6%88%E6%81%AF%E5%A2%9E%E5%8A%A0%E2%80%9C%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81%E2%80%9D)
	- [3.4 典型的离线消息收发流程](#3.4%20%E5%85%B8%E5%9E%8B%E7%9A%84%E7%A6%BB%E7%BA%BF%E6%B6%88%E6%81%AF%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B)
	- [3.5 聊天消息重复的问题](#3.5%20%E8%81%8A%E5%A4%A9%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E9%97%AE%E9%A2%98)
- [4. 什么是IM系统的消息时序一致性](#4.%20%E4%BB%80%E4%B9%88%E6%98%AFIM%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B6%88%E6%81%AF%E6%97%B6%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7)
- [5. 什么是IM系统的端到端加密](#5.%20%E4%BB%80%E4%B9%88%E6%98%AFIM%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86)

## 1. 什么是IM系统
### 1.1 IM的应用场景
IM不局限于聊天、社交这类“典型”的应用中，实际上，在直播、在线客服、物联网等所有需要实时互动、高实时性的场景中，都需要用到IM技术。
**下面这些场景是我们大家都熟悉的，都用到了IM技术：**  
- 1）微信、qq、钉钉等主流IM应用：这是IM技术的典型应用场景；
- 2）微博、知乎等社区应用：它们利用IM技术实现了用户私信等点对点聊天；
- 3）抖音、快手等直播/短视频应用：它们利用IM技术实现了与主播的实时互动；
- 4）米家等智能家居物联网应用：利用IM技术实现实时控制、远程监控等；
- 5）滴滴、Uber等共享家通类应用：利用IM技术实现位置共享；
- 6）在线教育类应用：利用IM技术实现在线白板。
### 1.2 IM的典型架构
![](IM/attachments/a4fc1b26f4988b0378c91855dfe155c0_MD5.jpeg)
**如上图所示，IM架构中的各分层职责如下：**  
- 1）客户端：作为与服务端进行消息收发通信的终端；
- 2）接入层：也叫网关层，为客户端收发消息提供入口；
- 3）逻辑层：负责IM系统各功能的核心逻辑实现；
- 4）存储层：负责IM系统相关数据的持久化存储，包括消息内容、账号信息、社交关系链等；
- 5）第三方服务：保证APP在未打开或后台运行时也能收到消息通知（这主要是第第3方消息推送服务，例如Apple的APNs推送通知服务）。
**尤其对于“接入层”，它的职责最为关键，具体是：**  
- 1）保持海量用户连接；
- 2）解析协议，对传输内容进行编解码；
- 3）维护客户端的连接（也叫“Session”）；
- 4）推送消息。
### 1.3 IM技术的特点
![](IM/attachments/3e234e7c38d88ceed2f68ac1b79e9de9_MD5.jpeg)
1) 实时性：单聊时要求低时延，超大规模群聊时要求高吞吐（就算延时高，那么多消息也看不过来哇）
2) 可靠性：要求就是不重不漏
3) 一致性：多端登录是IM的常见需求，这就需要在同一时刻，不同设备上的消息具有一致性
4) 安全性：数据传输安全、数据存储安全、消息内容安全
### 1.4 IM的功能组成
浅显的角度讲，一个典型的IM功能组成，无非就是以下5样：  
- 1）联系人列表；
- 2）聊天界面；
- 3）消息发送通道；
- 4）消息接收通道；
- 5）消息存储；
- 6）消息未读数。

#### 1）联系人列表
**要想建立联系人列表，你可能需要实现以下逻辑：**  
- 1）怎么能找到想要聊天的人？（需要实现随机查找？精确查找？）
- 2）怎么决定要不要跟这个人聊？（需要实现对方的个人信息查看）
- 3）开始发出好友请求；
- 4）被请求的一方，还可以决定是“同意”还是“拒绝”（“同意”该怎么处理？“拒绝”又该怎么处理？）。
#### 2）聊天界面
聊天界面是IM系统客户端的核心功能所在
**它应该具备的能力有：**  
- 1）各种聊天功能按钮：语音留言、图片、文字、表情、文件、实时电话、实时视频等；
- 2）各种聊天消息显示：各种消息都有不同的UI显示元素和处理逻辑；
- 3）流畅的使用体验：大量不同类型的消息显示时，不能卡顿；
- 4）即时显示聊天消息：网络线程收到的消息，要马上在UI上显示出来；
- 5）历史消息的加载：上次聊过的内容也得显示出来吧。
#### 3）消息发送通道
![](IM/attachments/21ff43b9763c3ae61d754381a475e60a_MD5.jpeg)
消息发送并不是简单的利用tcp或udp建立socket长连接，然后write一下完事的。不同于简单的两端通信，IM的场景是三端通信：服务端以及两个客户端之间的通信，所以要确保一个消息从客户端A发送到客户端B，必须确保客户端A-服务端-客户端B中的每个环节都不会出错。
- 1）如何保证这条socket长连接时一直处于可用的状态？
- 2）当socket长连接不可用时，用户此时发送的消息该怎么处理？
- 3）怎么保证发送的消息不丢？
- 4）怎么保证发送的消息不复重？
- 5）怎么保证发送的消息不乱序？
- 6）当对方不在线时，发送的消息去哪了？
- 7）发送的消息，能保证实时送到？
#### 4）消息接收通道 
**要实现一个可靠的消息接收通道，也并非易事：**  
- 1）如何保证socket长连接通道能随时处于良好的连接状态（随时接收对方write的消息）；
- 2）当socket长连接断开时，对方发送消息该怎么实现？
- 3）当socket恢复连接时，怎么恢复之前的聊天现场？
- 4）当我收到对方的消息时，对方怎么知道我已经收到了？
- 5）当重复收到对方的消息时，该怎么处理？
- 6）当收到的消息时序有错乱，该怎么处理？
#### 5）消息存储
**那么，哪些情况下需要进行消息存储呢：**  
- 1）对方不在线时：聊天消息应该存储（这叫离线消息存储）；
- 2）对方在线时：聊天消息也要存到本地存储（这叫消息缓存）；
- 3）对方在线或不在线时：聊天消息都要存到服务端（用于实现多设备的消息漫游和同步）。
与之而来的技术问题有：
- 1）离线消息该怎么多久？
- 2）图片、短视频、大文件这类的离线消息，多媒体文件该怎么存（有可能量会很大）？
- 3）当本地的消息积累太多时，怎么能保证本地存储的性能？
- 4）当应用更新、升级或异常时，怎么能保证本地存储的完整性（不被破坏）？
- 5）怎么能保证多设备消息能不丢、不重、不乱？
下面是一个IM系统的典型存储架构设计
![](IM/attachments/d396b372d4e2c97348b20c7e0a8347ab_MD5.jpeg)
#### 6）消息未读数
消息未读数也随着IM系统的特性产生以下问题：
- 1）未读数是客户端实现还是服务端实现？
- 2）会话未读和总未读怎么保持一致？
- 3）多终端情况下，怎么保证未读数的一致性（我在这台设备上读没读，那台设备怎么知道的？）？
通常，消息未读数也会作为一个独立的微服务CountServer
## 2. 什么是IM系统的实时性
在HTML5中的WebSocket出现之前，因为无法直接使用TCP、UDP通信协议，Web端的IM系统很难实现真正的“实时性”
下面说明Web端即时通信技术的演进
### 2.1 短轮询技术
![](IM/attachments/f435e233207c74eebf2400c3bfd75252_MD5.jpeg)
在早期的Web时代，数据获取的主要方式就是“请求-响应”方式。存在的问题就是：用户不知道新消息什么时候回来，服务端也没有办法主动通知用户。
简单来说，短轮询技术就是IM客户端定时轮询服务端，服务端收到请求即刻查询是否存在新消息，有就返回给客户端，没有则返回空并关闭连接。
**好处是：**  
- 1）技术简单，容易实现；
- 2）可维护性强，因为它没什么复杂的。  
**坏处是：**  
- 1）因为无法预知数据是否存在，所以多数请求是无用的，浪费计算资源；
- 2）为了提升实时性，高频率的请求会加大服务端的性能负载。
### 2.2 长轮询技术
**从技术上来说，长轮询实现的IM相较于短轮询最大的改进在于**：短轮询情况下，服务端不管有没有新消息，请求结束就会立即断开连接。而长轮询时，如果本次请求没有新消息发生，不会马上断开连接并返回，而是会将本次连接“挂起”一段时间，如果在这段“挂起”时间内有新的聊天消息出现，就能马上读取并立即返回给客户端，接着结束本次连接。一段时间后又会再次发起请求，如此周而复始。
![](IM/attachments/32660a6d74aabd230747ef124c87e9b1_MD5.jpeg)
**长轮询的优点是：**  
- 1）相较于短连询，一定程度降低了服务端请求负载；
- 2）相较于短连询，实时性有提升，因为它是主动“等”消息。  
**长轮询的缺点是：**  
- 1）长论询模式下，连接“挂起”的这段时间内，服务端需要配合开启单独的消息查询线程，仍然存在无用功；
- 2）相较于短连询模式，在一次长轮询结束、下次轮询发起前的窗口期内，仍然存在“实时性”盲区。
### 2.3 轮询无法实现真正的“实时性”
对于Web端即时通讯技术来说，上面提到的无论是短轮询，还是长轮询，它们都存在“实时性”盲区。
短轮询如下图：
![](IM/attachments/026dba93c76277525dd1f52c04b25b9c_MD5.jpeg)
长轮询如下图：
![](IM/attachments/f14392c47374f1fa7f14c1f5647dab0e_MD5.jpeg)
轮询技术的实时性缺陷源于HTTP协议的设计
HTTP协议设计的目的，就是为了实现“请求--响应”这种模式的数据交互，也就是众所周之的“短连接”设计。而无论是短轮询还是长轮询，都跳不出HTTP的先天技术逻辑（请求--响应--断开）。
所以，归根到底，想要基于HTTP协议来实现IM，要达到真正的“实时性”，是相当勉强的。因为HTTP设计的目的，就是用“短连接”来简化传统TCP长连接通信带来的复杂性，而IM的实时性恰好要用到的又是TCP的长连接特性，所以这就是个悖论。
### 2.4 WebSocket让Web端IM真正的“实时性”变成可能
HTML5中带来了WebSocket技术，WebSocket是真正的全双工双向通信技术
> 简单来说，WebSocket是HTTP协议的升级，专门用于双向通信的协议

下图是轮询技术与WebSocket的对比图
![](IM/attachments/3c6be60e1a2dd185d0353fdda1d88cbc_MD5.jpeg)
**从上图可以看出：**  
- 1）轮询技术一问一答，在下一个请求发起之前，存在“实时性”盲区；
- 2）WebSocket一旦建立连接后，数据可以随时双向通信（即客户端可以随时向服务端发消息，服务端也可以随时通知客户端有新消息）。
**总结一下WebSocket 的优点是：**  
- 1）真正的实时性：支持客户端与服务端真正的双向实时通信；
- 2）大幅降低负载：少了轮询技术中高频率无用的请求，可大大降低服务端QPS压力；
- 3）网络开销降低：一次连接，随时使用，再也不用轮询技术中每次发起HTTP请求（随之而来的是每次HTTP的大量冗余协议头信息等）。
## 3. 什么是IM系统的可靠性
一般来说，IM系统的消息“可靠性”，通常就是指聊天消息投递的可靠性（准确的说，这个“消息”是广义的，因为还存用户看不见的各种指令，为了通俗，统称“消息”）。  
**从用户行为来讲，消息“可靠性”应该分为两种类型：**  
- 1）**在线消息的可靠性**：即发送消息时，接收方当前处于“在线”状态；
- 2）**离线消息的可靠性**：即发送消息时，接收方当前处于“离线”状态。  
**从具体的技术表现来讲，消息“可靠性”包含两层含义：**  
- 1）**消息不丢**：这很直白，发出去的消息不能像进了黑洞一样，一脸懵逼可不行；
- 2）**消息不重**：这是丢消息的反面，消息重复了也不能容忍。  
**对于“消息不丢”这个特征来说，细化下来，它又包含两重含义：**  
- 1）已明确被对方收到；
- 2）已明确未被对方收到。  
是的，对于第1）重含义好理解，第2）重含义的意思是：当对方没有成功收到时，你的im系统也必须要感知到，否则，它同样属于被“丢”范畴。
### 3.1 典型的在线消息收发流程
![](IM/attachments/dd568b15f505f56ef2a447cc2fb64549_MD5.jpeg)
这是一个典型的服务端中转型IM架构，一条消息从客户端A发出后，需要先经过 IM 服务器来进行中转，然后再由 IM 服务器推送给客户端B，这种模式也是目前最常见的 IM 系统的消息分发架构。
IM不可以是P2P模式的吗？
**原因是以下两个很明显的弊端：**  
- 1）P2P模式下，IM运营者很容易被用户架空（无法监管到用户行为，用户涉黄了怕不怕？）；
- 2）P2P模式下，群聊这种业务形态，很难实现（我要在千人群中发消息给，不可能我自已来分发1000次吧）。
如果在两条通路上都使用TCP，可以保证IM聊天消息的可靠性吗？答案是否定的。
### 3.2 TCP不能保证在线消息的“可靠性”
众所周知的是，TCP实现了网络数据包的可靠传输，因此可以说TCP是可靠的
**第一个问题是**：既然 TCP 本身是具备可靠性的，为什么还会出现消息接收端（Receiver）丢失消息的情况？
![](IM/attachments/9fcb2732167211ed2c48b3edc7978bb4_MD5.jpeg)
**一句话总结上图的含义**：网络层的可靠性不等同于业务层的可靠性。
**数据可靠抵达网络层之后，还需要一层层往上移交处理，可能的处理有：**  
- 1）安全性校验；
- 2）binary 解析；
- 3）model 创建；
- 4）写 db；
- 5）存入 cache；
- 6）UI 展示；
- 7）以及一些边界问题：比如断网、用户突然退出登陆、磁盘已满、内存溢出、app奔溃、突然关机等等。  
项目的功能特性越多，网络层往上的处理出错的可能性就越大。
### 3.3 为在线消息增加“可靠性保证”
可以参考TCP协议的超时、重传、确认机制实现应用层的可靠性保证。
**具体来说就是：**  
- 1）在应用层构造一种ACK消息，当接收方正确处理完消息后，向发送方发送ACK；
- 2）假如发送方在超时时间内没有收到ACK，则认为消息发送失败，需要进行重传或其他处理。
![](IM/attachments/4794501c2d57cdd3bd7f7bdaf4f388af_MD5.jpeg)
我们可以把整个过程分为两个阶段。  
**_阶段1：clientA -> server_**  
- 1-1：clientA向server发送消息(msg-Req)；
- 1-2：server收取消息，回复ACK(msg-Ack)给clientA；
- 1-3：一旦clientA收到ACK即可认为消息已成功投递，第一阶段结束。  
无论msg-A或ack-A丢失，clientA均无法在超时时间内收到ACK，此时可以提示用户发送失败，手动进行重发。  
**_阶段2：server -> clientB_**  
- 2-1：server向clientB发送消息(Notify-Req)；
- 2-2：clientB收取消息，回复ACK(Notify-ACk)给server；
- 2-3：server收到ACK之后将该消息标记为已发送，第二阶段结束。  
无论msg-B或ack-B丢失，server均无法在超时时间内收到ACK，此时需要重发msg-B，直到clientB返回ACK为止。
### 3.4 典型的离线消息收发流程
下面是一个典型的IM离线消息流程图
![](IM/attachments/3a85c98b187aadb287ca204cdf2dda04_MD5.jpeg)
**离线消息收发流程也可划分为两个阶段：**  
**_阶段1：clientA -> server_**  
- 1-1：clientA向server发送消息(msg-Req) ；
- 1-2：server发现clientB离线，将消息存入offline-DB。  
**_阶段2：server -> clientB_**  
- 2-1：clientB上线后向server拉取离线消息(pull-Req) ；
- 2-2：server从offline-DB检索相应的离线消息推送给clientB(pull-res)，并从offline-DB中删除。    
**显然**：离线消息收发过程同样存在消息丢失的可能性。
**举例来说**：假设pull-res没有成功送达clientB，而offline-DB中已删除，这部分离线消息就彻底丢失了。
因此，我们需要在应用层上增加可靠性的保障机制。
下图是增加了可靠性保障后的离线消息收发流程：
![](IM/attachments/695f2bca7e05446ab84b50a4fbdf6cf6_MD5.jpeg)
**与初始的离线消息收发流程相比，上图增加了1-3、2-4、2-5步骤：**  
- 1-3：server将消息存入offline-DB后，回复ACK(msg-Ack)给clientA，clientA收到ACK即可认为消息投递成功；
- 2-4：clientB收到推送的离线消息，回复ACK(res-Ack)给server；
- 2-5：server收到res-ACk后确定离线消息已被clientB成功收取，此时才能从offline-DB中删除。
**当离线消息的量较大时**：如果对每条消息都回复ACK，无疑会大大增加客户端与服务器的通信次数。这种情况我们通常使用批量ACK的方式，对多条消息仅回复一个ACK。在某此后IM的实现中是将所有的离线消息按会话进行分组，每组回复一个ACK，假如某个ACK丢失，则只需要重传该会话的所有离线消息。同样也是参考了TCP重传机制中的SR重传机制。
### 3.5 聊天消息重复的问题
上面通过在应用层加入重传、确认机制后，杜绝了消息丢失的可能性。
**但由于重试机制的存在，我们会遇到一个新的问题**：那就是同一条消息可能被重复发送。
消息去重的方式其实非常简单，一般是根据消息的唯一标志(id)进行过滤。  
**具体过程在服务端和客户端可能有所不同：**  
- 1）**客户端**：我们可以通过构造一个map来维护已接收消息的id，当收到id重复的消息时直接丢弃；
- 2）**服务端** ：收到消息时根据id去数据库查询，若库中已存在则不进行处理，但仍然需要向客户端回复Ack（因为这条消息很可能来自用户的手动重发）。
## 4. 什么是IM系统的消息时序一致性
**所谓的一致性，在IM中通常指的是消息时序的一致性，那就是：**  
- 1）聊天消息的上下文连续性；
- 2）聊天消息的绝对时间序。
**再具体一点，IM消息的一致性体现在：**  
- 1）单聊时：要保证发送方发出聊天消息的顺序与接收方看到的顺序一致；
- 2）群聊时：要保证所有群员看到的聊天消息，与发送者发出消息时的绝对时间序是一致的。
### 4.1 为什么保证消息时序一致性很困难？
实际上，在IM这种高性能场景下，服务端为了追求高吞吐、高并发，用到了多线程、异步IO等等技术。  
在这种情况下，“高并发”与“顺序”对于IM服务端来说，本来就是矛盾的，这就有点鱼与熊掌的味道了（两者很难兼得）。
下面将具体说明技术难点所在。
1) 没有全局时钟
![](IM/attachments/ccd67b55a4491f8b2af4ec6aeb39ad7b_MD5.jpeg)
在分布式环境下，客户端+服务端后台的各种后台服务，都各自分布在不同的机器上，机器之间都是使用的本地时钟，没有一个所谓的“全局时钟”（也没办法做到真正的全局时钟），那么所谓的消息时序也就没有真正意义上的时序基准点。所以消息时序问题显然不是“本地时间”可以完全决定的。
2) 多发送方问题
![](IM/attachments/0f61ba5df69ac5c5fd50b0c9f2d98bab_MD5.jpeg)
服务端分布式的情况下，不能用“本地时间”来保证时序性，那么能否用接收方本地时间表示时序呢？  
遗憾的是，由于多个客户端的存在（比如群聊时），即使是一台服务器的本地时间，也无法表示“绝对时序”。  
**如上图所示**：绝对时序上，APP1先发出msg1，APP2后发出msg2，都发往服务器web1，网络传输是不能保证msg1一定先于msg2到达的，所以即使以一台服务器web1的时间为准，也不能精准描述msg1与msg2的绝对时序。
3) 多接收方问题
![](IM/attachments/e778158dea241792a9fc186100c8ec36_MD5.jpeg)
多发送方不能保证时序，假设只有一个发送方，能否用发送方的本地时间表示时序呢？遗憾的是，由于多个接收方的存在，无法用发送方的本地时间，表示“绝对时序”。  
如上图，绝对时序上，web1先发出msg1，后发出msg2，由于网络传输及多接收方的存在，无法保证msg1先被接收到先被处理，故也无法保证msg1与msg2的处理时序。
4) 网络传输与多线程问题
![](IM/attachments/9e3a0ddf92688ac770226cdea4b3607d_MD5.jpeg)
既然多发送方与多接收方都难以保证绝对时序，那么假设只有单一的发送方与单一的接收方，能否保证消息的绝对时序一致性呢？  
结论是悲观的，由于网络传输与多线程的存在，这仍然不行。  
如上图所示，web1先发出msg1、后发出msg2，即使msg1先到达（网络传输其实还不能保证msg1先到达），由于多线程的存在，也不能保证msg1先被处理完。
### 4.2 如何保证绝对的消息时序一致性？
**从纯技术的角度来说，假设：**  
- 1）只有一个发送方；
- 2）一个接收方；
- 3）上下游连接只有一条socket连接；
- 4）通过阻塞的方式通讯。
显然这种情况可以保证绝对的消息一致性，但是IM系统的性能就很堪忧了。。。
### 4.3 实用的优化思路
1) 一对一单聊场景
在一对一单聊的场景下，实际上不用维护全局的消息时序一致性，只需要保证两个人**会话**层面的消息一致性。
所以常见的优化方案就是，在A往B发送消息中，添加一个发送方A本地的一个绝对时序，来表示接收方B的展示时序。
2) 多对多群聊场景
首先肯定不能像一对一单聊场景那样以发送方的绝对时序来保证，需要一个单点作为全局时序。
**或许**：我们可以利用服务器的单点做序列化。
![](IM/attachments/05b1351a1e68e24053f4060dae4eb887_MD5.jpeg)
**如上图所示，此时IM群聊的发送流程为**：
- 1）sender1发出msg1，sender2发出msg2；
- 2）msg1和msg2经过接入集群，服务集群；
- 3）service层到底层拿一个唯一seq，来确定接收方展示时序；
- 4）service拿到msg2的seq是20，msg1的seq是30；
- 5）通过投递服务讲消息给多个群友，群友即使接收到msg1和msg2的时间不同，但可以统一按照seq来展现。
**这个方法：**  
- 1）优点是：能实现所有群友的消息展示时序相同；
- 2）缺点是：这个生成全局递增序列号的服务很容易成为系统瓶颈。
**从技术角度看**：群消息其实也不用保证全局消息序列有序，而只要保证一个群内的消息有序即可，这样的话，“消息id序列化”就成了一个很好的思路。
![](IM/attachments/0fe0c8b450e020233dc9757750261265_MD5.jpeg)
上图这个方案中，service层不再需要去一个统一的后端拿全局seq（序列号），而是在service连接池层面做细小的改造，保证一个群的消息落在同一个service上，这个service就可以用本地seq来序列化同一个群的所有消息，保证所有群友看到消息的时序是相同的。
对于IM系统来说，绝对意义上的时序很难保证，但通过服务端生成的单调递增消息ID的方式，利用递增ID来保证时序性，也是一个很可性的方案。
IM消息ID技术专题可以访问： http://www.52im.net/thread-1998-1-1.html
## 5. 什么是IM系统的端到端加密
### 5.1 网络通讯数据加密的三个层次
一般的数据加密可以在通信的3个层次来实现：链路加密、节点加密和端到端加密。
1) 链路加密
对于链路加密(又称在线加密)，所有消息在被传输之前进行加密，在每一个节点对接收到的消息进行解密，然后先使用下一个链路的密钥对消息进行加密，再进行传输。
在到达目的地之前，一条消息可能要经过许多通信链路的传输。由于在每一个中间传输节点消息均被解密后重新进行加密，因此，包括路由信息在内的链路上的所有数据均以密文形式出现，这样，链路加密就掩盖了被传输消息的源点与终点。由于填充技术的使用以及填充字符在不需要传输数据的情况下就可以进行加密，这使得消息的频率和长度特性得以掩盖，从而可以防止对通信业务进行分析。
2) 节点加密
两者均在通信链路上为传输的消息提供安全性，都在中间节点先对消息进行解密，然后进行加密。因为要对所有传输的数据进行加密，所以加密过程对用户是透明的。然而，与链路加密不同，节点加密不允许消息在网络节点以明文形式存在，它先把收到的消息进行解密，然后采用另一个不同的密钥进行加密，这一过程是在节点上的一个安全模块中进行。  
节点加密要求报头和路由信息以明文形式传输，以便中间节点能得到如何处理消息的信息，因此这种方法对于防止攻击者分析通信业务是脆弱的。
3) 端到端加密
端到端加密允许数据在从源点到终点的传输过程中始终以密文形式存在。采用端到端加密(又称脱线加密或包加密)，消息在被传输时到达终点之前不进行解密，因为消息在整个传輸过程中均受到保护，所以即使有节点被损坏也不会使消息泄露。
端到端加密系统通常不允许对消息的目的地址进行加密，这是囚为每一个消息所经过的节点都要用此地址来确定如何传输消息。由于这种加密方法不能掩盖被传输消息的源点与终点，因此它对于防止攻击者分析通信业务是脆弱的。
**没有使用端到端加密时的通信原理图（各个环节都存在泄密的可能）**：
![](IM/attachments/f9f01268fbd6155b62ec11bef8b4e777_MD5.jpeg)
**使用端到端加密后的通信原理图（除了发送者和接收者，其它环境都是密文状态）**：
![](IM/attachments/c5e5cef441ce3d5e5242b254f7103281_MD5.jpeg)
### 5.2 IM系统中端到端加密原理
在IM系统中，当用户A发送消息给用户B时，IM系统会生成一对公钥和私钥，并将公钥发送给用户B。用户A使用用户B的公钥对消息进行加密，然后将加密后的消息发送给用户B。
在用户B接收到消息后，使用自己的私钥对消息进行解密，从而获取明文内容。由于私钥只有用户B拥有，因此除了用户B之外，任何人都无法解密消息。
简单来说，就是公钥私钥加密。