## 75 高可用架构如何避免单点，经典方案Keepalived＋VIP用了都说好！
Keepalived+VIP是什么？
基于Keepalived的Nginx高可用架构的落地配置？
Keepalived的VIP抢占问题与脑裂问题？

规避单点是HA架构最基本的考量

Keepalived是Linux2轻量级别的高可用解决方案。
Keepalived主要是通过虚拟路由冗余(VRRP)来实现高可用功能，Keepalived部署和使用非常的简单，所有配置只需要一个配置文件即可以完成。
虚拟路由冗余协议(Virtual Router Redundancy Protocol,简称VRRP)是由IETF提出的解决局域网中配置静态网关出现单点失效现象的路由协议

VIP(虚拟IP)是虚拟的IP,与实际网卡绑定的的P地址不同，VIP在内网中被动态的映射到不同的MAC地址上，也就是映射到不同的机器设备上，Keepalived通过"心跳机制”监测服务器状态，Master主节点宕机则自动将"IP漂移”到Backup备机上实现高可用。
==通过VIP隐藏实际IP，Keepalived底层的IP漂移技术完成HA==
![](IT%E8%80%81%E9%BD%90/attachments/1bc610cdf13c1385c34f4e2412003714_MD5.jpeg)
==如果因为Keepalived挂掉==，master无法发送心跳包，Backup自动升级为Master，产生IP飘逸设置虚拟IP为.5，继续提供服务
当master恢复后，Keepalived自动IP漂移回原master，新mater降级回backup

基于VIP的Nginx高可用方案
![](IT%E8%80%81%E9%BD%90/attachments/c007266fe8aef5ed8dc16b7d352af648_MD5.jpeg)
如果Keepalived没挂，结点上的Nginx挂掉，还可以发送心跳包，怎么办呢？
![](IT%E8%80%81%E9%BD%90/attachments/2c23c911f5d02a96285dfce8f6a6a9cb_MD5.jpeg)
新增nginx_check.sh脚本，如果nginx服务挂掉，主动杀掉keepalived进程。 

但常规的配置两个nginx只有一个提供服务，可以配置为互为主备
![](IT%E8%80%81%E9%BD%90/attachments/c68dbb863c635a435add3f77c2c8d2bf_MD5.jpeg)
这里DNS是单点，但不用考虑DNS的高可用问题，通常DNS没有单点故障问题。

通常情况下，原master挂掉后恢复，会ip漂移回原master，但这中间会存在一段时间的不可用。可以使用nopreempt非抢占模式，原master恢复后降级为从属结点。

还有一种情况会发生脑裂：主从之间的vrrp心跳包因为网络问题不可达，导致主和从都认为自己是主节点。
![](IT%E8%80%81%E9%BD%90/attachments/8a3d455bd188654b0e9e7248b105dcab_MD5.jpeg)
pkill -9是强制停止，不会清除使用的虚拟ip，所以需要使用pkill正常结束

## 76 自己一次脑瘫引发的XSS漏洞，导致上千客户泄密
未对用户输入的信息进行转义，导致xss；注意转义逻辑在服务端做；可以使用Spring的HtmlUtils的htmlEscape方法进行转义。

## 77 几张图讲明白RocketMQ高可用方案
RocketMQ有哪些角色
RocketMQ消息生产消费流程
Broker主挂了RocketMQ怎么办
Broker主从都挂了RocketMQ怎么办
NameServer挂了RocketMQ怎么办
同步复制与异步复制之间的区别与应用场景

![](IT%E8%80%81%E9%BD%90/attachments/c67db46eb39f4783ddb9e23c015b05f4_MD5.jpeg)
每一个Broker就是一个服务器
![](IT%E8%80%81%E9%BD%90/attachments/d0cb0a7c036ca804c3e4f71bc7533fd5_MD5.jpeg)
NameServer就是注册中心
![](IT%E8%80%81%E9%BD%90/attachments/e5b37ad4b41cb98f4ac52fb18a04d68c_MD5.jpeg)
2-3NameServer防止单点故障，主Broker提供写入和读取，从Broker只提供读取；主从Broker通过日志同步；主Broker的数据不重叠
a主挂掉，a主停止写入服务，consumer从a从拉数据，slave-a不会升级为master-a，同步复制不会丢数据，异步复制不会丢数据
![](IT%E8%80%81%E9%BD%90/attachments/d58a88eace695f0033c8b1271741bf50_MD5.jpeg)
a主挂后，Producer重试发送到b主

a主a从都挂后，a挤压的数据无法获取，但已经持久化不会丢失；
![](IT%E8%80%81%E9%BD%90/attachments/5bb2591b039edd63040d3f526e6b3364_MD5.jpeg)

## 78 看不懂MySQL执行计划谈什么SQL优化
![](IT%E8%80%81%E9%BD%90/attachments/d49623eb3a267643d54eb041badaa22c_MD5.jpeg)

## 79 MySQL多表关联执行计划
什么是NLJ嵌套循环连接
为什么我的多表关联执行效率这么差
其他类型多表关联执行计划怎么分析

NLJ，Nest Loop Join嵌套循环连接，与两层for循环类似，是驱动表中的每一条记录与被驱动表中的记录进行比较判断。
![](IT%E8%80%81%E9%BD%90/attachments/67412c85f6ad5efcd7ccf83cac138c0d_MD5.jpeg)
只有在外键上建立索引，关联表的索引才能生效。驱动顺序从上到下：chapter-》history-》member
![](IT%E8%80%81%E9%BD%90/attachments/31ed0a4c2ecb91d5e3f68473aedb590f_MD5.jpeg)
把多表关联改为where in子查询，查询优化器的执行计划不会改变，仍然使用NLJ查询
![](IT%E8%80%81%E9%BD%90/attachments/c33086ae7634e8b4ed9d8c0cf74925ac_MD5.jpeg)
多表关联改为from子句筛选，查询优化器仍然使用NLJ查询
![](IT%E8%80%81%E9%BD%90/attachments/1f5bd30d6cffdb2866ceceafd82e410a_MD5.jpeg)
select包含子查询，会出现dependent subquery依赖子查询，属于NLJ范畴
![](IT%E8%80%81%E9%BD%90/attachments/11a59f03f62c0b435b286c907012c5d7_MD5.jpeg)
子查询中出现多结果集运算union all，会出现derived，\<derived3>代表id=3的DERIVED以及之后的UNION操作。
![](IT%E8%80%81%E9%BD%90/attachments/d83f3f14a4ba58d592741ed2f7de343b_MD5.jpeg)
少用UNION、多用UNION ALL，UNION去重是基于内存临时表；临时表特性是如果内存够使用内存，不够自动拆功能键MyISAM引擎表，IO效率会变差。

## 80 本地消息表模式是如何保障分布式最终一致性的
![](IT%E8%80%81%E9%BD%90/attachments/ecf0b8ac9208e93ebef0101004f6e7de_MD5.jpeg)
要求订单系统和库存系统实现最终一致性，可以使用==本地消息表模式==
![](IT%E8%80%81%E9%BD%90/attachments/6318728c9527d3c0f778b4408ec930ec_MD5.jpeg)
订单系统增加消息表以及定时任务，定时扫描消息表中正在处理的消息，push到消息队列Broker的process_queue队列中；库存系统处理完push到return_queue中，订单系统更新状态为处理完毕。
![](IT%E8%80%81%E9%BD%90/attachments/a7655478eebbca48c6be218875f8c7d2_MD5.jpeg)
实质是消息队列+定时任务+状态机

> 分布式事务解决方案：
> [后端 - 分布式事务最经典的七种解决方案 - 分布式事务 - SegmentFault 思否](https://segmentfault.com/a/1190000040321750)
> 本地消息表
> 2PC
> TCC(Try-Confirm-Cancel)：Try资源预留、Confirm确认提交、Cancel失败时回滚
> 最大努力通知：下游一致性通过异步通知+重试机制保证，上游完成本地事务，尽最大可能通知下游，可能会失败
> Saga事务：将全局事务拆成一系列本地事务，每个事务有对应的 **补偿操作**。如果中途失败，按顺序执行补偿操作撤销之前的操作。

|方案|一致性|实现复杂度|性能|典型场景|
|---|---|---|---|---|
|**本地消息表**|最终一致|中|中|电商订单+消息投递|
|**2PC**|强一致|高|低|传统银行转账|
|**TCC**|接近强一致|高|中|金融支付、账户扣款|
|**最大努力通知**|最终一致（不保证100%）|低|高|通知、积分、日志|
|**Saga**|最终一致|中|中|长事务（订单、预订）|

## 81 契约测试 Spring Cloud Contract
分布式环境测试v1：
电商系统同步调用商品服务
服务不稳定、团队严重耦合、开发进度缓慢
测试v2：
通过Mock Server将电商系统和商品服务解耦，开发完毕后逐渐切换至真实环境。
团队解耦、逐步切换、拟真环境
但是当服务多了之后，也产生了很多的Mock Server，这回导致API更新滞后、测试时外部环境依赖严重、并且mock的数据是模拟出来的静态数据
测试v3：
API调用方和API提供方提供契约文件
好处就是API及时更新、不产生外部依赖、并且是真实数据测试

测试流程：
![](IT%E8%80%81%E9%BD%90/attachments/ad7c28380ded497774a697ee2797b98e_MD5.jpeg)
执行单元测试时会自动生成stubs.jar

## 82 基于Prometheus的指标监控架构
监控一般分为指标监控Monitoring、链路追踪Tracing、日志收集Logging。
指标监控：内存、CPU、线程数量。。。
链路追踪：完成某个业务的调用路径
日志收集：ELK日志处理
![](IT%E8%80%81%E9%BD%90/attachments/0675a5b2c1cfa918a71804d2a293e5b9_MD5.jpeg)
官方Exporter地址： https:/github.com/prometheus
node_exporter: Linux类操作系统相关数据的采集程序
jmx_exporter: Java进程指标采集程序
mysqld_exporter: MySQLserver数据采集程序
redis exporter: Redis数据采集程序

## 83 分布式架构全链路压测
全链路压测，是基于真实的生产环境来模拟海量的并发用户请求和数据，对整个业务链路进行压力测试，试图找到所有潜在性能瓶颈点并持续优化的实践。
全链路压测的应用场景，不仅仅包括验证系统在峰值期间的稳定性，还会包含新系统上线后的性能瓶颈定位以及站点容量的精准规划。
![](IT%E8%80%81%E9%BD%90/attachments/604e886319289eb467d037c6c0ed85c6_MD5.jpeg)
子系统过多，调用链路复杂，传统测试方法无法全面覆盖。
![](IT%E8%80%81%E9%BD%90/attachments/b4c50193b127da4cabdc9416d6db23aa_MD5.jpeg)全链路压测解决了单系统压测的问题。
	优势：
	基于生产环境的测试现场
	真实的用户操作过程
	能够发现各种系统间潜在问题
	技术难点：
	海量并发请求的发起
	全链路压测流量的隔离

实现全链路压测，需要考虑：
- 开发流量重放系统，忠实还原用户操作轨迹
- JMeter集群，通过Jekins Job向单独JMeter发起流量测试
- 研发压测引擎，自动实现脚本与测试数据分发与结果回传的工作
- 提前规划好机房，在多城市部署JMeter)压测节点，向不同区域分发
- 全方面构建Prometheus:指标监控、SkyWalking链路追踪、EFK日志
- 收集，做好系统的方位检测与预警机制
- 基于“打标”区分真实数据与模拟数据
- 备建影子库，将模拟数据存储在不同的数据库，实现物理层面隔离
- 调整数据统计口径，图表、报表统计过滤掉模拟数据
- 必要的Mock处理，如支付网关、三方支付等外部环境要搭建拟真环境
==全链路压测风险很大，目前没有多少公司实施==

全链路压测可以发现准生产UAT环境因为数据量、数据分布发现不到的问题。

## 84 升级Log4J2，以及SpringBoot Logback日志配置
