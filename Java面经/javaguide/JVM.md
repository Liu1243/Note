针对HotSpot虚拟机
常见面试题：
- 介绍下 Java 内存区域（运行时数据区）
- Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）
- 对象的访问定位的两种方式（句柄和直接指针两种方式）

## 运行时数据区域
1.8和之前的版本略有不同。分为1.7和1.8介绍。
1.7：
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/da0feeedefe9342591c9cd302347db69_MD5.jpeg)
1.8：
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/215e702dd14a8cc1bf344509d1bd36df_MD5.jpeg)
线程私有的：
- 程序计数器
- 虚拟机栈
- 本地方法栈
Java虚拟机规范对运行时数据区域的规定是相当宽松的。

**程序计数器**：
当前线程所执行的字节码的行号指示器。==是唯一一个不会OOM的内存区域==，随线程的创建而创建，结束而死亡。

**Java虚拟机栈**
Navie方法调用是通过本地方法栈实现的，其他所有Java方法调用都是通过虚拟机栈实现的。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/8e23d21a22a1caff2628badf4438e5a6_MD5.jpeg)
**局部变量表** 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
**操作数栈**作为方法调用的中转站使用，存放方法执行过程中产生的中间计算结果。计算过程中产生的临时变量也存在操作数栈中。
**动态链接**服务一个方法调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/39e5ed419c5591b885595243f7405bec_MD5.jpeg)
那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
 **栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。**
 如果栈的内存大小可以动态扩展， 那么当虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。
- **`StackOverFlowError`：** 如果栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 那么当虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。
HotSpot虚拟机的栈容量是不可以动态拓展的。

**本地方法栈**
**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

**堆**
内存最大，所有线程共享，虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**
随着JIT以及逃逸分析技术的成熟，栈上分配、标量替换优化使得对象可以在栈上分配。1.7开启逃逸分析，如果方法中的对象引用没有被返回或未被外面使用（没有逃逸出去），对象就可以在栈上分配。
Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。java堆可分为Eden、Survivor、Old 等空间。
1.7之前堆内存分为：Young、Old、Permanent
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/53061486b60887d7aea0b02059fa5714_MD5.jpeg)
8之后PermGen被metaspace取代，原空间使用的是本地内存。
首先在Eden区域分配，经过一个新生代GC，如果还存活进入S0或者S1，年龄+1，如果年龄到15，晋升到老年代，阈值通过-XX:MaxTenuringThreshold指定，设置的值应该在 0-15，否则会爆出以下错误：
`MaxTenuringThreshold of 20 is invalid; must be between 0 and 15`
为什么年龄只能是0-15？
记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。
HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
对象头包括两部分：标记字段（Mark Word）和类型指针（Klass Word）。
年龄信息存在Mrak Word中，占用4bit。
> “Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累加，当累加到某个年龄时，所累加的大小超过了 Survivor 区的一半，则取这个年龄和 `MaxTenuringThreshold` 中更小的一个值，作为新的晋升年龄阈值”。

堆最容易OOM：
- **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
- **`java.lang.OutOfMemoryError: Java heap space`** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值，8之后 64位JVM 为物理内存的1/4

**方法区**
虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。
**方法区和永久代以及元空间是什么关系呢？**
8之前的实现是永久代，8之后的实现是元空间。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/fd435a9495557a4a9c5571ab664e5bc1_MD5.jpeg)
**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**
1. 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
> 当元空间溢出时会得到如下错误：`java.lang.OutOfMemoryError: MetaSpace`

使用-XX:MaxMetaspaceSize标志设置最大元空间大小，默认为unlimited，意味着只受系统内存的限制；-XX:MetaspaceSize调整定义元空间的初始大小，如果未指定则根据运行时动态调整。
2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
3. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。
4. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
方法区常用参数：
1.8之前
```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```
1.8，方法区（HotSpot的永久代）被移除，元空间取代之，元空间使用的是本地内存。
```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
与永久代不同的是，如果不指定大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

**运行时常量池**
Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。
字面值就是整数、浮点数。符号引用有类符号引用、字段符号引用等。
常量池表会在类加载后存放到方法区的运行时常量池中。
运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。
既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误。

**字符串常量池**
JVM为提升性能和减少内存消耗针对字符串（String类）开辟的一块区域，为了避免字符串的重复创建。
HotSpot 虚拟机中字符串常量池的实现是 `src/hotspot/share/classfile/stringTable.cpp` ,`StringTable` 可以简单理解为一个固定大小的`HashTable` ，容量为 `StringTableSize`（可以通过 `-XX:StringTableSize` 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。
1.7之前，字符串常量池存在永久代。1.7字符串常量池和静态变量从永久代移动到了堆中。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/82664e94c8b41a025aa6f3f96a378b79_MD5.jpeg)
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/8562a92e0fd7ae12eabb07c0ac79aa67_MD5.jpeg)
1.7为什么要将字符串常量池移动到堆中？
永久代GC回收效率太低，只有Full GC才会对永久代执行GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

**直接内存**
直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。
1.4引入的NIO，引入了一种基于**通道（Channel）与**缓存区（Buffer）**的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

## HotSpot虚拟机对象
HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。

对象的创建：
1. 类加载检查
new指令，检查是否能在常量池中定位到这个类的符号引用，并检查这个符号引用代表的类是否已经被加载过、解析和初始化过。如果没有，需要执行类加载过程。
2. 分配内存
对象所需内存在类加载完成可确认。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。
- 指针碰撞：
    - 适用场合：堆内存规整（即没有内存碎片）的情况下。
    - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
    - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表：
    - 适用场合：堆内存不规整的情况下。
    - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
    - 使用该分配方式的 GC 收集器：CMS
选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

内存分配并发问题：
JVM通过以下两种方式保证线程安全：
- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
3. 初始化零值
内存分配完成后，将分配到的内存空间初始化为零值，保证对象的实例不赋初始值可以直接使用。
4. 设置对象头
初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。
5. 执行init方法
执行new指令后接着执行\<init>方法

对象的内存布局
对象在内存中的布局可以分为 3 块区域：**对象头（Header）**、**实例数据（Instance Data）**和**对齐填充（Padding）**。
对象头包括：
- Mark Word：存储对象运行时数据，如hashCode、GC age、锁状态
- klass pointer：对象指向它的类元数据的指针，JVM通过这个指针确定这个对象是哪个类的实例
**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。
HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象的大小必须是8字节的整数倍。需要对齐填充来补全。

对象的访问定位
程序通过栈上的reference数据操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。
句柄：
Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/59047e30035d9ad94bbc349f40c0a77b_MD5.jpeg)
直接指针：
reference 中存储的直接就是对象的地址。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/609e8f5409799ab844aed02645c8f000_MD5.jpeg)
使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
HotSpot使用直接指针的方式进行对象访问。

## JVM垃圾回收详解
- 如何判断对象是否死亡（两种方法）。
- 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
- 如何判断一个常量是废弃常量
- 如何判断一个类是无用的类
- 垃圾收集有哪些算法，各自的特点？
- HotSpot 为什么要分为新生代和老年代？
- 常见的垃圾回收器有哪些？
- 介绍一下 CMS,G1 收集器。
- Minor Gc 和 Full GC 有什么不同呢？

| 收集器                            | 代际     | 主要算法                | 线程并发性 | 适用场景                   | 优点                | 缺点                           |
| ------------------------------ | ------ | ------------------- | ----- | ---------------------- | ----------------- | ---------------------------- |
| **Serial**                     | 年轻代    | 复制算法                | 单线程   | 单核、小内存、客户端模式           | 实现简单、开销小、在单核下吞吐高  | 停顿时间长，不适合多核和大堆               |
| **Serial Old**                 | 老年代    | 标记-整理               | 单线程   | 单核、小内存、与 Serial 搭配     | 实现简单，内存碎片少        | 停顿长，不适合多核大堆                  |
| **Parallel Scavenge**          | 年轻代    | 复制算法                | 多线程   | 吞吐优先的批处理、后台任务          | 吞吐量高，自动调整停顿时间     | 停顿时间可能较长，响应不稳定               |
| **Parallel Old**               | 老年代    | 标记-整理               | 多线程   | 与 Parallel Scavenge 搭配 | 吞吐量高，适合大堆批处理      | 延迟较高                         |
| **ParNew**                     | 年轻代    | 复制算法                | 多线程   | 与 CMS 搭配的年轻代回收         | 并行效率高，停顿低         | 只能和 CMS 搭配，性能受限              |
| **CMS（Concurrent Mark-Sweep）** | 老年代    | 标记-清除               | 多线程并发 | 低延迟、交互型应用              | 低停顿、并发回收          | 内存碎片、需要额外 CPU 资源、失败会 Full GC |
| **G1（Garbage First）**          | 整堆（分区） | 标记-复制 + 标记-整理       | 多线程并发 | 大堆、延迟可控场景              | 可预测停顿时间、分区回收、减少碎片 | 调优复杂，短期吞吐不如 Parallel         |
| **ZGC**                        | 整堆     | 标记-复制（Region-Based） | 并发    | 超大堆（TB级）、低延迟           | 停顿时间极低（<10ms）、可扩展 | JDK11 起支持，初期功能有限             |
| **Shenandoah**                 | 整堆     | 并发标记-整理             | 并发    | 大堆、低延迟                 | 停顿时间低，整理并发执行      | 吞吐低于 G1，调优复杂                 |
- **Serial 系列**：适合单核、小堆内存的 Client 模式。
- **Parallel 系列**：吞吐量优先，适合后台批处理、大吞吐任务。
- **CMS**：低延迟，但可能产生内存碎片，JDK14 后被标记为废弃。
- **G1**：JDK9 之后的默认收集器，平衡延迟与吞吐。
- **ZGC** / **Shenandoah**：现代低延迟收集器，支持超大堆和毫秒级停顿。

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。
在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：
1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)
**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存**

### 内存分配和回收原则
对象优先在Eden区分配
当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。
当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 `allocation1` 无法存入 Survivor 空间，所以只好通过 **分配担保机制** 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 `allocation1`，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。

大对象直接进入老年代  
大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。
避免将大对象放入新生代，减少新生代的垃圾回收频率。
- G1 垃圾回收器会根据 `-XX:G1HeapRegionSize` 参数设置的堆区域大小和 `-XX:G1MixedGCLiveThresholdPercent` 参数设置的阈值，来决定哪些对象会直接进入老年代。
- Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(`XX:ThresholdTolerance`是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。

长期存活的对象进入老年代
对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。
对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

