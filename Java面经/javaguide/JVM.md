针对HotSpot虚拟机
常见面试题：
- 介绍下 Java 内存区域（运行时数据区）
- Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）
- 对象的访问定位的两种方式（句柄和直接指针两种方式）

## 运行时数据区域
1.8和之前的版本略有不同。分为1.7和1.8介绍。
1.7：
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/da0feeedefe9342591c9cd302347db69_MD5.jpeg)
1.8：
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/215e702dd14a8cc1bf344509d1bd36df_MD5.jpeg)
线程私有的：
- 程序计数器
- 虚拟机栈
- 本地方法栈
Java虚拟机规范对运行时数据区域的规定是相当宽松的。

**程序计数器**：
当前线程所执行的字节码的行号指示器。==是唯一一个不会OOM的内存区域==，随线程的创建而创建，结束而死亡。

**Java虚拟机栈**
Navie方法调用是通过本地方法栈实现的，其他所有Java方法调用都是通过虚拟机栈实现的。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/8e23d21a22a1caff2628badf4438e5a6_MD5.jpeg)
**局部变量表** 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
**操作数栈**作为方法调用的中转站使用，存放方法执行过程中产生的中间计算结果。计算过程中产生的临时变量也存在操作数栈中。
**动态链接**服务一个方法调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/39e5ed419c5591b885595243f7405bec_MD5.jpeg)
那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
 **栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。**
 如果栈的内存大小可以动态扩展， 那么当虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。
- **`StackOverFlowError`：** 如果栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 那么当虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。
HotSpot虚拟机的栈容量是不可以动态拓展的。

**本地方法栈**
**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

**堆**
内存最大，所有线程共享，虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**
随着JIT以及逃逸分析技术的成熟，栈上分配、标量替换优化使得对象可以在栈上分配。1.7开启逃逸分析，如果方法中的对象引用没有被返回或未被外面使用（没有逃逸出去），对象就可以在栈上分配。
Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。java堆可分为Eden、Survivor、Old 等空间。
1.7之前堆内存分为：Young、Old、Permanent
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/53061486b60887d7aea0b02059fa5714_MD5.jpeg)
8之后PermGen被metaspace取代，原空间使用的是本地内存。
首先在Eden区域分配，经过一个新生代GC，如果还存活进入S0或者S1，年龄+1，如果年龄到15，晋升到老年代，阈值通过-XX:MaxTenuringThreshold指定，设置的值应该在 0-15，否则会爆出以下错误：
`MaxTenuringThreshold of 20 is invalid; must be between 0 and 15`
为什么年龄只能是0-15？
记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。
HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
对象头包括两部分：标记字段（Mark Word）和类型指针（Klass Word）。
年龄信息存在Mrak Word中，占用4bit。
> “Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累加，当累加到某个年龄时，所累加的大小超过了 Survivor 区的一半，则取这个年龄和 `MaxTenuringThreshold` 中更小的一个值，作为新的晋升年龄阈值”。

堆最容易OOM：
- **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
- **`java.lang.OutOfMemoryError: Java heap space`** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值，8之后 64位JVM 为物理内存的1/4

**方法区**
虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。
**方法区和永久代以及元空间是什么关系呢？**
8之前的实现是永久代，8之后的实现是元空间。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/fd435a9495557a4a9c5571ab664e5bc1_MD5.jpeg)
**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**
1. 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
> 当元空间溢出时会得到如下错误：`java.lang.OutOfMemoryError: MetaSpace`

使用-XX:MaxMetaspaceSize标志设置最大元空间大小，默认为unlimited，意味着只受系统内存的限制；-XX:MetaspaceSize调整定义元空间的初始大小，如果未指定则根据运行时动态调整。
2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
3. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。
4. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
方法区常用参数：
1.8之前
```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```
1.8，方法区（HotSpot的永久代）被移除，元空间取代之，元空间使用的是本地内存。
```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
与永久代不同的是，如果不指定大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

**运行时常量池**
Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。
字面值就是整数、浮点数。符号引用有类符号引用、字段符号引用等。
常量池表会在类加载后存放到方法区的运行时常量池中。
运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。
既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误。

**字符串常量池**
JVM为提升性能和减少内存消耗针对字符串（String类）开辟的一块区域，为了避免字符串的重复创建。
HotSpot 虚拟机中字符串常量池的实现是 `src/hotspot/share/classfile/stringTable.cpp` ,`StringTable` 可以简单理解为一个固定大小的`HashTable` ，容量为 `StringTableSize`（可以通过 `-XX:StringTableSize` 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。
1.7之前，字符串常量池存在永久代。1.7字符串常量池和静态变量从永久代移动到了堆中。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/82664e94c8b41a025aa6f3f96a378b79_MD5.jpeg)
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/8562a92e0fd7ae12eabb07c0ac79aa67_MD5.jpeg)
1.7为什么要将字符串常量池移动到堆中？
永久代GC回收效率太低，只有Full GC才会对永久代执行GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

**直接内存**
直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。
1.4引入的NIO，引入了一种基于**通道（Channel）与**缓存区（Buffer）**的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

## HotSpot虚拟机对象
HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。

对象的创建：
1. 类加载检查
new指令，检查是否能在常量池中定位到这个类的符号引用，并检查这个符号引用代表的类是否已经被加载过、解析和初始化过。如果没有，需要执行类加载过程。
2. 分配内存
对象所需内存在类加载完成可确认。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。
- 指针碰撞：
    - 适用场合：堆内存规整（即没有内存碎片）的情况下。
    - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
    - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表：
    - 适用场合：堆内存不规整的情况下。
    - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
    - 使用该分配方式的 GC 收集器：CMS
选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

内存分配并发问题：
JVM通过以下两种方式保证线程安全：
- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
3. 初始化零值
内存分配完成后，将分配到的内存空间初始化为零值，保证对象的实例不赋初始值可以直接使用。
4. 设置对象头
初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。
5. 执行init方法
执行new指令后接着执行\<init>方法

对象的内存布局
对象在内存中的布局可以分为 3 块区域：**对象头（Header）**、**实例数据（Instance Data）**和**对齐填充（Padding）**。
对象头包括：
- Mark Word：存储对象运行时数据，如hashCode、GC age、锁状态
- klass pointer：对象指向它的类元数据的指针，JVM通过这个指针确定这个对象是哪个类的实例
**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。
HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象的大小必须是8字节的整数倍。需要对齐填充来补全。

对象的访问定位
程序通过栈上的reference数据操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。
句柄：
Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/59047e30035d9ad94bbc349f40c0a77b_MD5.jpeg)
直接指针：
reference 中存储的直接就是对象的地址。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/609e8f5409799ab844aed02645c8f000_MD5.jpeg)
使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
HotSpot使用直接指针的方式进行对象访问。

## JVM垃圾回收详解
- 如何判断对象是否死亡（两种方法）。
- 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
- 如何判断一个常量是废弃常量
- 如何判断一个类是无用的类
- 垃圾收集有哪些算法，各自的特点？
- HotSpot 为什么要分为新生代和老年代？
- 常见的垃圾回收器有哪些？
- 介绍一下 CMS,G1 收集器。
- Minor Gc 和 Full GC 有什么不同呢？

| 收集器                            | 代际     | 主要算法                | 线程并发性 | 适用场景                   | 优点                | 缺点                           |
| ------------------------------ | ------ | ------------------- | ----- | ---------------------- | ----------------- | ---------------------------- |
| **Serial**                     | 年轻代    | 复制算法                | 单线程   | 单核、小内存、客户端模式           | 实现简单、开销小、在单核下吞吐高  | 停顿时间长，不适合多核和大堆               |
| **Serial Old**                 | 老年代    | 标记-整理               | 单线程   | 单核、小内存、与 Serial 搭配     | 实现简单，内存碎片少        | 停顿长，不适合多核大堆                  |
| **Parallel Scavenge**          | 年轻代    | 复制算法                | 多线程   | 吞吐优先的批处理、后台任务          | 吞吐量高，自动调整停顿时间     | 停顿时间可能较长，响应不稳定               |
| **Parallel Old**               | 老年代    | 标记-整理               | 多线程   | 与 Parallel Scavenge 搭配 | 吞吐量高，适合大堆批处理      | 延迟较高                         |
| **ParNew**                     | 年轻代    | 复制算法                | 多线程   | 与 CMS 搭配的年轻代回收         | 并行效率高，停顿低         | 只能和 CMS 搭配，性能受限              |
| **CMS（Concurrent Mark-Sweep）** | 老年代    | 标记-清除               | 多线程并发 | 低延迟、交互型应用              | 低停顿、并发回收          | 内存碎片、需要额外 CPU 资源、失败会 Full GC |
| **G1（Garbage First）**          | 整堆（分区） | 标记-复制 + 标记-整理       | 多线程并发 | 大堆、延迟可控场景              | 可预测停顿时间、分区回收、减少碎片 | 调优复杂，短期吞吐不如 Parallel         |
| **ZGC**                        | 整堆     | 标记-复制（Region-Based） | 并发    | 超大堆（TB级）、低延迟           | 停顿时间极低（<10ms）、可扩展 | JDK11 起支持，初期功能有限             |
| **Shenandoah**                 | 整堆     | 并发标记-整理             | 并发    | 大堆、低延迟                 | 停顿时间低，整理并发执行      | 吞吐低于 G1，调优复杂                 |
- **Serial 系列**：适合单核、小堆内存的 Client 模式。
- **Parallel 系列**：吞吐量优先，适合后台批处理、大吞吐任务。
- **CMS**：低延迟，但可能产生内存碎片，JDK14 后被标记为废弃。
- **G1**：JDK9 之后的默认收集器，平衡延迟与吞吐。
- **ZGC** / **Shenandoah**：现代低延迟收集器，支持超大堆和毫秒级停顿。

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。
在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：
1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)
**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存**

### 内存分配和回收原则
对象优先在Eden区分配
当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。
当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 `allocation1` 无法存入 Survivor 空间，所以只好通过 **分配担保机制** 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 `allocation1`，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。

大对象直接进入老年代  
大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。
避免将大对象放入新生代，减少新生代的垃圾回收频率。
- G1 垃圾回收器会根据 `-XX:G1HeapRegionSize` 参数设置的堆区域大小和 `-XX:G1MixedGCLiveThresholdPercent` 参数设置的阈值，来决定哪些对象会直接进入老年代。
- Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(`XX:ThresholdTolerance`是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。

长期存活的对象进入老年代
对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。
对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

> ==动态年龄计算==
> Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 `-XX:TargetSurvivorRatio=percent` 来设置，参见 [issue1199](https://github.com/Snailclimb/JavaGuide/issues/1199) ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值

> **默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.**

**主要进行gc的区域**
针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：
部分收集 (Partial GC)：
- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
整堆收集 (Full GC)：收集整个 Java 堆和方法区。

**空间分配担保**
空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。
> JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 `-XX:HandlePromotionFailure` 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 `-XX: HandlePromotionFailure` 设置不允许冒险，那这时就要改为进行一次 Full GC。
> 
> JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。

### 死亡对象判断方法
引用计数法
**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。**

可达性分析算法
这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。
**哪些对象可以作为 GC Roots 呢？**
- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- JNI（Java Native Interface）引用的对象
**对象可以被回收，就代表一定会被回收吗**
可达性分析需要经历两次标记过程：
第一次标记不可达对象，判断是否需要执行finalize？是则放入F-Queue，否则直接回收；当finalize完成后，第二次标记，如果还是没有和GC Roots建立引用链，直接回收。
相当于finalize给了不可达对象第二次机会，如果finalize方法中重新建立了链接，那么就不会回收。

> `Object` 类中的 `finalize` 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 `finalize` 方法会被逐渐弃用移除。忘掉它的存在吧！

**引用类型总结**
1.2之前只有一种引用类型reference
JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱），强引用就是 Java 中普通的对象，而软引用、弱引用、虚引用在 JDK 中定义的类分别是 `SoftReference`、`WeakReference`、`PhantomReference`。
强引用：
`String strongReference = new String("abc");`垃圾回收器绝不会回收它
软引用：
```java
// 软引用
String str = new String("abc");
SoftReference<String> softReference = new SoftReference<String>(str);
```
如果内存空间不足了，就会回收这些对象的内存。软引用可用来实现内存敏感的高速缓存。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。
常见的用法就是“图片缓存”场景：
```java
/**
 * 用软引用做图片缓存，同时用 ReferenceQueue 监控哪些缓存被回收了
 */
public class ImageCacheWithSoftRef {

    // 真正的缓存容器： key → 软引用
    private final Map<String, SoftReference<byte[]>> cache = new HashMap<>();

    // 引用队列：用来接收被回收的 SoftReference 对象
    private final ReferenceQueue<byte[]> queue = new ReferenceQueue<>();

    /** 把图片放进缓存 */
    public void put(String key, byte[] imageData) {
        // 注意第三个参数：把 SoftReference 和队列挂接
        cache.put(key, new SoftReference<>(imageData, queue));
    }

    /** 从缓存里读图片 */
    public byte[] get(String key) {
        SoftReference<byte[]> ref = cache.get(key);
        return (ref == null) ? null : ref.get();
    }

    /** 主动触发一次“看看谁被回收了” */
    public void cleanUp() {
        Reference<? extends byte[]> ref;
        // 轮询队列里所有被回收的 SoftReference
        while ((ref = queue.poll()) != null) {
            // 虽然 SoftReference 本身还在 cache 里，但是指向的对象已经没了
            System.out.println("检测到软引用对象被回收：" + ref);

            // 这里可以把它从 map 里彻底删掉，避免 map 越来越大
            cache.values().removeIf(r -> r == ref);
        }
    }
}
```

弱引用：
```java
String str = new String("abc");
WeakReference<String> weakReference = new WeakReference<>(str);
str = null; //str变成软引用，可以被收集
```
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
同样的，弱引用也可以和一个引用队列联合使用。

虚引用：
"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
```java
String str = new String("abc");
ReferenceQueue queue = new ReferenceQueue();
// 创建虚引用，要求必须与一个引用队列关联
PhantomReference pr = new PhantomReference(str, queue);
```
**虚引用主要用来跟踪对象被垃圾回收的活动**。
**虚引用与软引用和弱引用的一个区别在于：** 虚引用==必须==和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

很少使用弱引用和虚引用，软引用使用较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

**如何判断一个常量是废弃常量？**
运行时常量池主要回收的是废弃的常量。
- **JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代**
- **JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代** 。
- **JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)**

各种常量池的比较：[JVM常量池最全详解-常量池/运行时常量池/字符串常量池/基本类型常量池，看这一篇就够了\_java如何查看字符串是否在常量池-CSDN博客](https://blog.csdn.net/weixin_42679575/article/details/128021153)
总体来说，常量池是编译时期的概念，生成字节码期间生成的，而运行时常量池则是运行时期的概念，包含常量池的内容。
如果字符串常量池中的字符串，没有任何String对象引用该字符串常量的话，说明该字符串常量是废弃常量。

如何判断一个类是无用的类？
方法区主要回收的是无用的类。
类需要同时满足下面 3 个条件才能算是 **“无用的类”**：
- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

### 垃圾回收算法
标记清除
两个明显的问题：
1. **效率问题**：标记和清除两个过程效率都不高。
2. **空间问题**：标记清除后会产生大量不连续的内存碎片。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/6b10e7f249fb95b1ddfac9989af6493d_MD5.jpeg)

复制算法
为了解决标记清除算法的效率以及内存碎片问题，复制收集算法出现了。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/1823e0a8a7e7abbd6cd73bcf08b25a3d_MD5.jpeg)
但依然存在下面这些问题：
- **可用内存变小**：可用内存缩小为原来的一半。
- **不适合老年代**：如果存活对象数量比较大，复制性能会变得很差。

标记整理算法
根据老年代特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/0147f9779d75afadf35f3feca3aa86c0_MD5.jpeg)
由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。

分代收集算法
==当前虚拟机的垃圾收集都采用分代收集算法==，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
比如在新生代中，每次收集都会有大量对象死去，所以可以选择“复制”算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
面试题：HotSpot为什么要分为新生代和老年代？

### 垃圾回收器
**根据具体应用场景选择适合自己的垃圾收集器**。
JDK 默认垃圾收集器（使用 `java -XX:+PrintCommandLineFlags -version` 命令查看）：
- JDK 8: Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK22: G1

Serial收集器
串行收集器，是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。
新生代采用**标记复制**算法，老年代使用**标记整理**算法。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/fe5019a1b09522f4c33938d8438a9dda_MD5.jpeg)
Serial收集器**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。

ParNew收集器
ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。
**新生代采用标记-复制算法，老年代采用标记-整理算法。**
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/719b9773337d47e3bfd7a37322c8fb8c_MD5.jpeg)
是Server模式下虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

Parallel Scavenge收集器
Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 **那么它有什么特别之处呢？**
Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。
**新生代采用标记-复制算法，老年代采用标记-整理算法。**
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/a604a5a44156de1c4090de18e7bb1c2d_MD5.jpeg)
==这是1.8默认收集器==，JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old

Serial Old收集器
**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/fe5019a1b09522f4c33938d8438a9dda_MD5.jpeg)

Parallel Old收集器
Parallel Scavenge收集器的老年代版本。使用多线程和标记整理算法。注重吞吐量和CPU资源。

CMS收集器
**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**
**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**
CMS 收集器是一种 **“标记-清除”算法**实现的，运行步骤：
- **初始标记：** 短暂停顿，标记直接与 root 相连的对象（根对象）；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。
主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：
- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**
**CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。**

G1收集器
**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。**
被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：
- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。
步骤：
- **初始标记**： 短暂停顿（Stop-The-World，STW），标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象
- **并发标记**：与应用并发运行，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。
- **最终标记**： 短暂停顿（STW），处理并发标记阶段结束后残留的少量未处理的引用变更。
- **筛选回收**：根据标记结果，选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度。
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/88eb64f31ac1413ee1e4b6309950d99b_MD5.jpeg)
**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。
**从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。**

ZGC收集器
与 CMS、ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。
ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。ZGC 最大支持 16TB 的堆内存。
ZGC 在 Java11 中引入，处于试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java15 已经可以正式使用了。
不过，默认的垃圾回收器依然是 G1。
在 Java21 中，引入了分代 ZGC，暂停时间可以缩短到 1 毫秒以内。


