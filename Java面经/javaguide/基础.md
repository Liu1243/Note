[JavaGuide（Java学习&面试指南） \| JavaGuide](https://javaguide.cn/home.html)
## Java
### 基础
1. AOT
JDK 9 引入了一种新的编译模式 **AOT(Ahead of Time Compilation)** 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。
![](Java%E9%9D%A2%E7%BB%8F/attachments/9aac71c60e90934fa46fbac8ce48db06_MD5.jpeg)
**既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？**

我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 `.class` 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。
==AOT是执行前编译，JIT是运行时编译；所以AOT无法支持反射、动态代理等操作，而现在大多数框架如Spring会使用到反射以及动态代理的特性，所以不能使用AOT==

2. 基本类型和包装类型
**为什么说是几乎所有对象实例都存在于堆中呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行**逃逸分析**，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

注意：**基本数据类型存放在栈中是一个常见的误区！** 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆/方法区/元空间中。
==局部变量放置在栈中，成员变量在堆上==

3. 包装类型的缓存机制
Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `TRUE` or `FALSE`。
对于 `Integer`，可以通过 JVM 参数 `-XX:AutoBoxCacheMax=<size>` 修改缓存上限，但不能修改下限 -128。实际使用时，并不建议设置过大的值，避免浪费内存，甚至是 OOM。
其他包装类型的缓存范围则是固定的。
如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。
Float、Double并没有实现缓存机制，也不晓得能缓存什么，数值范围太大了。
![](Java%E9%9D%A2%E7%BB%8F/attachments/64bb7a08bb3c7dc0bf7cdea835979c52_MD5.jpeg)
==所以所有Integer对象之间值的比较，全部使用equals方法比较==

4. 自动装箱拆箱
**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**

5. 解决浮点数运算精度丢失问题？
使用`BigDecimal`

6. 超过long整型的数据因该如何表示？
使用`BigInteger`，该类内部使用`int[]`数组来存储任意大小的整型数据，但是运算效率低。

7. 字符型常量和字符串常量的区别？
==char在Java中占用两个字节==

8. 可变长参数
遇到方法重载的情况下，会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。
Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 `class`文件就可以看出来了。

9. 深拷贝和浅拷贝
![](Java%E9%9D%A2%E7%BB%8F/attachments/5e4182885c10b98e66114b4ce4319815_MD5.jpeg)

10. 为什么重写`equals()`时必须重写`hashCode()`方法？
- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。

9. String、StringBuffer、StringBuilder的区别？
**可变性**
String不可变
`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。
==StringBuilder、StringBuffer可变==
**线程安全性**
String、StringBuffer线程安全，`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁。
`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。
**性能**
每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

对三者使用的总结：
- 操作少量的数据: 适用 `String`
- 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
- 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

10. String为什么不可变
```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];
  //...
}
```
- 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
- `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

> 在 Java 9 之后，`String`、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串。

**Java 9 为何要将 `String` 的底层实现由 `char[]` 改成了 `byte[]` ?**
新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，`byte` 占一个字节(8 位)，`char` 占用 2 个字节（16），`byte` 相较 `char` 节省一半的内存空间。

JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。
如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，`byte` 和 `char` 所占用的空间是一样的。
==为了减少内存浪费。因为大部分字符串仅包含Latin-1字符，所以使用1个字节即可；而char需要占用两个字节，空间浪费了百分之五十。

11. 字符串拼接用“+”还是StringBuilder？
Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。
字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 
==Java重载+，底层是通过StringBuilder的append()方法实现的==
不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。
在 JDK 9 中，字符串相加“+”改为用动态方法 `makeConcatWithConstants()` 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： `a+b+c` 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 append 的概念），并不如手动使用 StringBuilder 来进行拼接效率高。
==所以，在循环中不要使用字符串"+"，而是显示的使用StringBuilder对象append()方法，避免重复创建StringBuilder对象==

12. String equals()和Object equals()
String中的equals方式是重写过的，比较的是String字符串的值是否相等。Object的equals比较的是对象的内存地址。

13. 字符串常量池
**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

**String s1 = new String("abc");这句话创建了几个字符串对象？**
会创建1或者2个字符串对象
- 字符串常量池中不存在 "abc"：会创建 2 个 字符串对象。一个在字符串常量池中，由 `ldc` 指令触发创建。一个在堆中，由 `new String()` 创建，并使用常量池中的 "abc" 进行初始化。
- 字符串常量池中已存在 "abc"：会创建 1 个 字符串对象。该对象在堆中，由 `new String()` 创建，并使用常量池中的 "abc" 进行初始化。
字节码中`ldc (load constant)` 指令的确是从常量池中加载各种类型的常量，包括字符串常量、整数常量、浮点数常量，甚至类引用等。

14. String intern方法的作用
`String.intern()` 是一个 `native` (本地) 方法，用来处理字符串常量池中的字符串对象引用。
- `intern()` 方法的主要作用是确保字符串引用在常量池中的唯一性。
- 当调用 `intern()` 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。

14. String类型的变量和常量做“+”运算时发生了什么？
JDK1.8
```java
String str1 = "str";
String str2 = "ing";
String str3 = "str" + "ing";
String str4 = str1 + str2;
String str5 = "string";
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```
**对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。**
==对于字符串常量的拼接会进行常量折叠的代码优化==
对于 `String str3 = "str" + "ing";` 编译器会给你优化成 `String str3 = "string";` 。

并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：

- 基本数据类型( `byte`、`boolean`、`short`、`char`、`int`、`float`、`long`、`double`)以及字符串常量。
- `final` 修饰的基本数据类型和字符串变量
- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）

**引用的值在程序编译器是无法确定的，编译器无法对其优化。**

---
对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。
```java
String str4 = new StringBuilder().append(str1).append(str2).toString();
```
我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 `StringBuilder` 或者 `StringBuffer`。

---
不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。
```java
final String str1 = "str";
final String str2 = "ing";
// 下面两个表达式其实是等价的
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true
```
被 `final` 关键字修饰之后的 `String` 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。

15. 异常
![](Java%E9%9D%A2%E7%BB%8F/attachments/71182ba2ef9b0a64e16c79311cda6d0c_MD5.jpeg)
- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
- **`Error`**：`Error` 属于程序无法处理的错误 ，不建议通过`catch`捕获 。例如 Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

**Checked Exception** 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 `catch`或者`throws` 关键字处理的话，就没办法通过编译。
**Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。
`RuntimeException` 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：
- `NullPointerException`(空指针错误)
- `IllegalArgumentException`(参数错误比如方法入参类型错误)
- `NumberFormatException`（字符串转换为数字格式错误，`IllegalArgumentException`的子类）
- `ArrayIndexOutOfBoundsException`（数组越界错误）
- `ClassCastException`（类型转换错误）
- `ArithmeticException`（算术错误）
- `SecurityException` （安全错误比如权限不够）
- `UnsupportedOperationException`(不支持的操作错误比如重复创建同一用户)

==**注意：不要在 finally 语句块中使用 return!**== 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。==除此之外，还会吞掉异常==

---
进阶一下：从字节码角度分析`try catch finally`这个语法糖背后的实现原理。
==其实也就是将finally中的代码复制三份，放在try、catch流程最后==

`try-with-resources`
- **适用范围（资源的定义）：** 任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象
- **关闭资源和 finally 块的执行顺序：** 在 `try-with-resources` 语句中，任何 catch 或 finally 块在声明的资源关闭后运行

从字节码的角度来看，对于必须要关闭的资源，try-with-resources比try-finall要好，因为报错的异常信息保留的更多。
==在传统try-finally结构中，如果try与finally都抛出异常，最终只会抛出finally中的异常。而在try-with-resources中，会使用addSuppressed将close的异常作为压制异常添加到try抛出的主异常中。==

16. 注解
注解本质是一个继承了`Annotation` 的特殊接口

注解只有被解析之后才会生效，常见的解析方法有两种：
- **编译期直接扫描**：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。

17. SPI
SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。
很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。

**SPI和API的区别**
![](Java%E9%9D%A2%E7%BB%8F/attachments/ab9215d6a8d42cdf135b977e88fbf56b_MD5.jpeg)
- 当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 **API**。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。
- 当接口存在于调用方这边时，这就是 **SPI** 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。

通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：

- 需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。
- 当多个 `ServiceLoader` 同时 `load` 时，会有并发问题。

18. 序列化与反序列化
对于不想进行序列化的变量，使用 `transient` 关键字修饰。
关于 `transient` 还有几点注意：
- `transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

常见的序列化协议：
JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。
像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。

**为什么不推荐使用JDK自带的序列化？**
- **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。
- **性能差**：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
- **存在安全问题**

19. IO
Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。
- `InputStream`/`Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。
**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**
- 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；
- 如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。

19. 语法糖
Java 中真正支持语法糖的是 Java 编译器而不是 JVM，JVM无法识别语法糖
`com.sun.tools.javac.main.JavaCompiler`的源码，你会发现在`compile()`中有一个步骤就是调用`desugar()`，这个方法就是负责解语法糖的实现的。
Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。

---
### 重要知识点
1. Java中只有值传递
- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。
2. 为什么不引入引用传递呢？
出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。
3. 序列化和反序列化
序列化协议在TCP/IP四层协议的应用层，OSI七层协议的表示层。
JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。
像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。
**Java自带的序列化方式**
只需要实现`java.io.Serializable`接口
```java
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Builder
@ToString
public class RpcRequest implements Serializable {
    private static final long serialVersionUID = 1905122041950251207L;
    private String requestId;
    private String interfaceName;
    private String methodName;
    private Object[] parameters;
    private Class<?>[] paramTypes;
    private RpcMessageTypeEnum rpcMessageTypeEnum;
}
```
序列化号 `serialVersionUID` 属于版本控制的作用。反序列化时，会检查 `serialVersionUID` 是否和当前类的 `serialVersionUID` 一致。如果 `serialVersionUID` 不一致则会抛出 `InvalidClassException` 异常。强烈推荐每个序列化类都手动指定其 `serialVersionUID`，如果不手动指定，那么编译器会动态生成默认的 `serialVersionUID`。
通常static变量属于类，不属于任何单个对象实例，所以不会包含在对象序列化的数据流里。==但是serialVersionUID是一个特例，序列化做了特殊处理，serialVersionUID的值会被写入到序列化的二进制流中，作为一个版本标识符。==
> 如果想显式指定 `serialVersionUID` ，则需要在类中使用 `static` 和 `final` 关键字来修饰一个 `long` 类型的变量，变量名字必须为 `"serialVersionUID"` 。

不想被序列化的变量，使用`transient`关键字修饰。 
关于 `transient` 还有几点注意：
- `transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。
为什么不推荐使用JDK自带的序列化？
- **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。
- **性能差**：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
- **存在安全问题**：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。
**Kryo**
Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。
另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。
**Protobuf**
Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。
**ProtoStuff**
由于 Protobuf 的易用性较差，它的哥哥 Protostuff 诞生了。
protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。
**Hessian**
Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。
Dubbo2.x默认启用的序列化方式是Hessian2，但对其进行了修改。
==Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用==

4. 泛型 && 通配符
Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。
泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。
项目中哪里用到了泛型？
自定义接口通用返回结果 CommonResult《T》 通过参数 T 可根据具体的返回类型动态指定结果的数据类型
构建集合工具类（参考 Collections 中的 sort , binarySearch 方法）。

什么是泛型擦除机制？为什么要擦除？
Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。
泛型本质上其实还是编译器的行为，为了保证引入泛型机制但不创建新的类型，减少虚拟机的运行开销，编译器通过擦除将泛型类转化为一般类。

既然编译器要把泛型擦除，那为什么还要用泛型呢？用 Object 代替不行吗？
使用泛型可在编译期间进行类型检测。
使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。
泛型可以使用自限定类型如 T extends Comparable 。

什么是桥方法？
桥方法（Bridge Method）用于继承泛型类时保证多态。
桥方法为编译器自动生成，非手写。
**桥方法是为了解决泛型擦除后，子类重写父类方法时方法签名不一致的问题。**
```java
class Node<T> {
    public T data;
    public void setData(T data) {
        this.data = data;
    }
}

class StringNode extends Node<String> {
    @Override
    public void setData(String data) {
        this.data = data;
    }
}
```
类型擦除后，
- `Node<T>` 的 `setData(T)` 变成了 `setData(Object)`。
- `StringNode` 的 `setData(String)` 变成了 `setData(String)`。
此时，**方法签名不一致**，看起来子类并没有重写父类的方法，这违反了多态。
编译器会**自动生成一个桥方法**：
```java
class StringNode extends Node<String> {
    // 桥方法（编译器自动生成）
    @Override
    public void setData(Object data) {
        setData((String) data); // 强转后调用真正的实现
    }

    // 子类真正的实现
    @Override
    public void setData(String data) {
        this.data = data;
    }
}
```

泛型有哪些限制？为什么？
泛型的限制由泛型擦除机制导致的。擦除为Object后无法进行类型判断。
- 只能声名不能实例化T类型变量
- 泛型参数不能是基本类型int等；只能是引用类型Integer等
- 不能实例化泛型参数的数组；**因为 Java 的泛型是「类型擦除」的，运行时无法确定泛型参数的具体类型，也就无法创建具有具体类型的数组，否则会破坏 Java 数组的类型安全机制。**
- 不能实例化泛型数组。Java泛型在运行时会被擦除为Object，而数组需要在运行时确定元素类型以用来类型检查。
- 泛型⽆法使⽤ Instance of 和 getClass() 进⾏类型判断。
- 不能实现两个不同泛型参数的同⼀接⼝，擦除后多个⽗类的桥⽅法将冲突
- 不能使⽤ static 修饰泛型变量

**通配符**
泛型类型是固定的，某些场景下使⽤起来不太灵活，于是，通配符就来了！通配符可以允
许类型参数变化，⽤来解决泛型⽆法协变的问题。
> **协变（Covariance）是指：如果 `A` 是 `B` 的子类型，那么 `Container<A>` 也被视为 `Container<B>` 的子类型，即支持“向上转型”的泛型关系。**
> 例如数组支持协变：
> String[] strArray = new String[10];
> Object[] objArray = strArray; 合法，数组协变
> objArray[0] = "Hellol"; 运行正常
> objArray[0]=123; 运行时错误，ArrayStoreException

**数组是协变的**，但**运行时检查类型**，防止存储错误类型。
**泛型默认不支持协变：**
List\<String> strList = new ArrayList<>();
List\<Object> objList = strList; // ❌ 编译错误！
- 即使 `String` 是 `Object` 的子类，`List<String>` **也不是** `List<Object>` 的子类。
- **这是为了防止类型不安全操作**（如向 `List<String>` 中插入 `Integer`）。
如何实现泛型协变？（使用通配符 `? extends`）
List\<String> strList = new ArrayList<>();
List\<? extends Object> objList = strList; // ✅ 合法！协变
**只能读取（get），不能写入（add）**，因为具体类型未知。

**协变是指子类型可以替换父类型的关系，例如 `String[]` 可以赋值给 `Object[]`。但 Java 泛型默认不支持协变，因为会引发类型安全问题，不过可以通过通配符 `? extends T` 实现协变，限制为只读操作。**

**T 是类型参数，用于定义类或方法时的占位符，表示一个确定的类型，支持类型一致性；而 ? 是通配符，表示未知类型，常用于方法参数中，支持上下边界限制，但不能用于定义类或方法。简单来说，T 是“类型变量”，? 是“类型通配”，用途不同，不能互换。**

List\<?> list 和 List有什么区别？
- List\<?> list 表示 list 是持有某种特定类型的 List，但是不知道具体是哪种类型。因此，我们添加元素进去的时候会报错。
- List list 表示 list 是持有的元素的类型是 Object ，因此可以添加任何类型的对象，只不过编译器会有警告信息。

什么是上边界通配符？什么是下边界通配符？
- **上边界通配符 `<? extends T>`：只能接收 `T` 或其子类型，常用于「读取」场景，不能写入（除了 `null`）。**
- **下边界通配符 `<? super T>`：只能接收 `T` 或其父类型，常用于「写入」场景，读取时只能拿到 `Object`。**
上边界通配符，只读
List\<? extends Number> list = new ArrayList\<Integer>();
Number n = list.get(0);  // ✅ 合法
list.add(123);           // ❌ 编译错误
下边界通配符，只写
List\<? super Integer\> list = new ArrayList\<Number>();
list.add(123);           // ✅ 合法
Integer i = list.get(0); // ❌ 编译错误，只能拿到 Object

Class\<?> 和 Class 的区别？
**`Class<?>` 是泛型写法，表示“某个未知类型的 Class 对象”，编译器会帮你做类型检查；`Class` 是非泛型（原始类型）写法，编译器会给出“未经检查的转换”警告，两者功能一样但前者更安全。**

4. Java反射机制
反射能够在运行时分析类以及执行类中方法。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

反射的应用场景了解吗？
像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。
**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。**
比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 `Method` 来调用指定的方法。
```java
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }


    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("after method " + method.getName());
        return result;
    }
}
```
Java中的注解的实现也用到了反射。

反射的优缺点？
**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

获取Class对象的四种方式？
- 知道具体类的情况
`Class alunbarClass = TargetObject.class;`
一般不知道具体类，基本是遍历包下的类来获取Class对象；这种方法获取的Class对象不会进行初始化
- 通过Class.forName()传入类的全路径获取
`Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");`
- 通过对象实例instance.getClass()
```java
TargetObject o = new TargetObject();
Class alunbarClass2 = o.getClass();
```
- **通过类加载器`xxxClassLoader.loadClass()`传入类路径获取:**
`ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");`
通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行


5. Java代理模式详解
**我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。**
**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。**
代理模式有静态代理和动态代理两种实现方式
**静态代理**
**静态代理中，我们对目标对象的每个方法的增强都是手动完成的**，**非常不灵活（_比如接口一旦新增加方法，目标对象和代理对象都要进行修改_）且麻烦(_需要对每个目标类都单独写一个代理类_）。**实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。
从 JVM 层面来说， **静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**
静态代理实现步骤:
- 定义一个接口及其实现类；
```java
public interface SmsService {
    String send(String message);
}
```
```java
public class SmsServiceImpl implements SmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
```
- 创建一个代理类同样实现这个接口
```java
public class SmsProxy implements SmsService {

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) {
        this.smsService = smsService;
    }

    @Override
    public String send(String message) {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method send()");
        smsService.send(message);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method send()");
        return null;
    }
}
```
- 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
```java
public class Main {
    public static void main(String[] args) {
        SmsService smsService = new SmsServiceImpl();
        SmsProxy smsProxy = new SmsProxy(smsService);
        smsProxy.send("java");
    }
}
```

**动态代理**
相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( _CGLIB 动态代理机制_)。
**从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**
Spring AOP、RPC框架中都使用了动态代理。
就 Java 来说，动态代理的实现方式有很多种，比如 **JDK 动态代理**、**CGLIB 动态代理**等等。

Java动态代理
**在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。**
JDK动态代理类使用步骤：
- 定义一个接口及其实现类；
```java
public interface SmsService {
    String send(String message);
}
```
```java
public class SmsServiceImpl implements SmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
```
- 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @author shuang.kou
 * @createTime 2020年05月11日 11:23:00
 */
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method " + method.getName());
        return result;
    }
}
```
- 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；
```java
public class JdkProxyFactory {
    public static Object getProxy(Object target) {
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(), // 目标类的类加载器
                target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个
                new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler
        );
    }
}
```
- 实际使用
```java
SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());
smsService.send("java");
```

CGLIB动态代理机制
**JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。**
**为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。**
[CGLIB](https://github.com/cglib/cglib)(_Code Generation Library_)是一个基于[ASM](http://www.baeldung.com/java-asm)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了[CGLIB](https://github.com/cglib/cglib)， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。

**在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。**

CGLIB动态代理类使用步骤：
- 引入依赖
```java
<dependency>
  <groupId>cglib</groupId>
  <artifactId>cglib</artifactId>
  <version>3.3.0</version>
</dependency>
```
- 定义一个类；
```java
package github.javaguide.dynamicProxy.cglibDynamicProxy;

public class AliSmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
```
- 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
```java
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * 自定义MethodInterceptor
 */
public class DebugMethodInterceptor implements MethodInterceptor {


    /**
     * @param o           被代理的对象（需要增强的对象）
     * @param method      被拦截的方法（需要增强的方法）
     * @param args        方法入参
     * @param methodProxy 用于调用原始方法
     */
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method " + method.getName());
        Object object = methodProxy.invokeSuper(o, args);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method " + method.getName());
        return object;
    }

}
```
- 通过 `Enhancer` 类的 `create()`创建代理类
```java
import net.sf.cglib.proxy.Enhancer;

public class CglibProxyFactory {

    public static Object getProxy(Class<?> clazz) {
        // 创建动态代理增强类
        Enhancer enhancer = new Enhancer();
        // 设置类加载器
        enhancer.setClassLoader(clazz.getClassLoader());
        // 设置被代理类
        enhancer.setSuperclass(clazz);
        // 设置方法拦截器
        enhancer.setCallback(new DebugMethodInterceptor());
        // 创建代理类
        return enhancer.create();
    }
}
```
- 实际使用
```java
AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);
aliSmsService.send("java");
```

**JDK动态代理和CGLIB动态代理对比**
- **JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。** 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
- 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

**静态代理和动态代理的对比**
- **灵活性**：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
- **JVM 层面**：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

6. BigDecimal详解
为了避免精度丢失，可以使用 `BigDecimal` 来进行浮点数的运算。
`BigDecimal` 可以实现对小数的运算，不会造成精度丢失。
**浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。**
![](Java%E9%9D%A2%E7%BB%8F/attachments/8e9e9383cfb32ba95ffbcc1769e39748_MD5.jpeg)

**BigDecimal常见用法**
创建
`BigDecimal(String val)`构造方法或者 `BigDecimal.valueOf(double val)` 静态方法来创建对象。
![](Java%E9%9D%A2%E7%BB%8F/attachments/ff4d4425616b821da95b91310ae213c9_MD5.jpeg)

加减乘除
`add` 方法用于将两个 `BigDecimal` 对象相加，`subtract` 方法用于将两个 `BigDecimal` 对象相减。`multiply` 方法用于将两个 `BigDecimal` 对象相乘，`divide` 方法用于将两个 `BigDecimal` 对象相除。
使用 `divide` 方法的时候尽量使用 3 个参数版本，并且`RoundingMode` 不要选择 `UNNECESSARY`，否则很可能会遇到 `ArithmeticException`（无法除尽出现无限循环小数的时候），其中 `scale` 表示要保留几位小数，`roundingMode` 代表保留规则。

大小比较
`a.compareTo(b)` : 返回 -1 表示 `a` 小于 `b`，0 表示 `a` 等于 `b` ， 1 表示 `a` 大于 `b`。

保留几位小数
通过 `setScale`方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。

**BigDecimal等值比较问题**
![](Java%E9%9D%A2%E7%BB%8F/attachments/aca80cadcdc67e7ed200909e30748d43_MD5.jpeg)
`equals()` 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 `compareTo()` 方法比较的时候会忽略精度。

`BigDecimal` 的实现利用到了 `BigInteger` （用来操作大整数）, 所不同的是 `BigDecimal` 加入了小数位的概念。

7. Java魔法类Unsafe详解
`Unsafe` 是位于 `sun.misc` 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 `Unsafe` 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 `Unsafe` 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 `Unsafe` 的使用一定要慎重。
另外，`Unsafe` 提供的这些功能的实现需要依赖本地方法（Native Method）。

为什么要使用本地方法呢？
- 需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。
- 对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。
- 程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。
对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。

Unsafe创建
```java
public final class Unsafe {
  // 单例对象
  private static final Unsafe theUnsafe;
  ......
  private Unsafe() {
  }
  @CallerSensitive
  public static Unsafe getUnsafe() {
    Class var0 = Reflection.getCallerClass();
    // 仅在引导类加载器`BootstrapClassLoader`加载时才合法
    if(!VM.isSystemDomainLoader(var0.getClassLoader())) {
      throw new SecurityException("Unsafe");
    } else {
      return theUnsafe;
    }
  }
}
```
`Unsafe` 类为一单例实现，提供静态方法 `getUnsafe` 获取 `Unsafe`实例。但不能直接调用这个静态方法，会抛出SecurityException异常。
这是因为在`getUnsafe`方法中，会对调用者的`classLoader`进行检查，判断当前类是否由`Bootstrap classLoader`加载，如果不是的话那么就会抛出一个`SecurityException`异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。

如果想使用Unsafe，如何获取其实例呢？
- 使用反射获取Unsafe类中已经实例化完成的单例对象theUnsafe
```java
private static Unsafe reflectGetUnsafe() {
    try {
      Field field = Unsafe.class.getDeclaredField("theUnsafe");
      field.setAccessible(true);
      return (Unsafe) field.get(null);
    } catch (Exception e) {
      log.error(e.getMessage(), e);
      return null;
    }
}
```
- 将调用Unsafe相关方法的类A所在的jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载。
`java -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径`

Unsafe功能
> 1. 内存操作
> 通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用`freeMemory`方法进行释放，否则会产生内存泄漏。
> 为什么要使用堆外内存？
> 	对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。
> 	提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。
> 典型应用：
> ==DirectByteBuffer 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。==
> 2. 内存屏障
> 编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（`Memory Barrier`）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。
> 内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。
> 基于读内存屏障可以实现和`volatile`相同的功能：字段在多线程下的可见性。
> 典型应用：
> ==Java8引入的锁机制StampedLock，是读写锁的改进版本。为解决数据不一致问题，其中的validate方法使用Unsafe的loadFence方法加入了一个loda内存屏障==`StampedLock` 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 `StampedLock` 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。
> 为了解决这个问题，`StampedLock` 的 `validate` 方法会通过 `Unsafe` 的 `loadFence` 方法加入一个 `load` 内存屏障。
> StampedLock乐观读过程：**获取戳记 → 快照读取 → 验证一致性 → 失败降级**
> **StampedLock 的写锁通过 CAS 修改内部 state 获取成功，返回 stamp 用于解锁，失败后阻塞等待，独占性强但不可重入。**
> 3. 对象操作
> Unsafe 提供了全部 8 种基础数据类型以及`Object`的`put`和`get`方法，并且所有的`put`方法都可以越过访问权限，直接修改内存中的数据。
> 除了对象属性的普通读写外，`Unsafe` 还提供了 **volatile 读写**和**有序写入**方法。顺序写入与`volatile`写入的差别在于，在顺序写时加入的内存屏障类型为`StoreStore`类型，而在`volatile`写入时加入的内存屏障是`StoreLoad`类型
> StoreStore屏障要求前面的写操作一定在后面写操作之前完成，不保证可见性；StoreLoad屏障保证前面的写操作一定在后面的读操作之前完成，保证可见性。
> ![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/a9854315c99d0dc42929275625b56f33_MD5.jpeg)
> 综上所述，在上面的三类写入方法中，在写入效率方面，按照`put`、`putOrder`、`putVolatile`的顺序效率逐渐降低。
> 对象实例化：使用 `Unsafe` 的 `allocateInstance` 方法，允许我们使用非常规的方式进行对象的实例化
> 有基于构造函数、反射以及Unsafe方法的方式；通过`allocateInstance`方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了`Class`对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。
> 如果构造函数为private类型，构造函数以及反射都无法创建对象，但allocateInstance方法仍然有效。
> 典型应用：
> ==allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用==
> 4. 数组操作
> `arrayBaseOffset` 与 `arrayIndexScale` 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。
> 典型应用：
> ==在 java.util.concurrent.atomic包下的 AtomicIntegerArray（可以实现对 Integer 数组中每个元素的原子性操作）中有典型的应用==
> 5. CAS 操作
> CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，`Unsafe` 提供的 CAS 方法（如 `compareAndSwapXXX`）底层实现即为 CPU 指令 `cmpxchg` 。
> 典型应用：
> ==在 JUC 包的并发工具类中大量地使用了 CAS 操作==
> 需要注意：
> CAS 操作本身存在 ABA 问题（一个值从 A 变为 B，再变回 A，CAS 检查时会认为值没有变过）。在某些场景下，如果值的变化历史很重要，可能需要使用 `AtomicStampedReference` 来解决。
> 长时间的自旋会消耗 CPU 资源。在竞争激烈或条件长时间不满足的情况下，可以考虑加入更复杂的退避策略（如 `Thread.sleep()` 或 `LockSupport.parkNanos()`）来优化。
> 6. 线程调度
> `Unsafe` 类中提供了`park`、`unpark`、`monitorEnter`、`monitorExit`、`tryMonitorEnter`方法进行线程调度。
> 此外，`Unsafe` 源码中`monitor`相关的三个方法已经被标记为`deprecated`，不建议被使用。
> 典型应用：
> ==Java 锁和同步器框架的核心类 AbstractQueuedSynchronizer (AQS)，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而 LockSupport 的 park、unpark 方法实际是调用 Unsafe 的 park、unpark方式实现的。==
> 7. Class 操作
> `Unsafe` 对`Class`的相关操作主要包括类加载和静态变量的操作方法。
> 需要使用`staticFieldOffset`方法获取类中静态属性信息。
> **使用`defineClass`方法允许程序在运行时动态地创建一个类**
> 使用该方法可以用来动态的创建一个匿名类，在`Lambda`表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（`Hidden classes`）一条中，指出将在未来的版本中弃用 `Unsafe` 的`defineAnonymousClass`方法。
> 典型应用：
> ==Lambda 表达式实现需要依赖 Unsafe 的 defineAnonymousClass 方法定义实现相应的函数式接口的匿名类。==
> 8. 系统信息
> addressSize返回系统指针的大小，返回值为4（32位系统）或 8（64位系统）、pageSize返回内存页的大小，此值为2的幂次方
> 典型应用：
> ==在java.nio.Bits类中，在使用pageCount计算所需的内存页的数量时，调用了pageSize方法获取内存页的大小。另外，在使用copySwapMemory方法拷贝内存时，调用了addressSize方法，检测 32 位系统的情况。==

3. Java SPI机制详解

4. Java语法糖详解



