## 线程
JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。由于绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核），在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。
用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。
**现在的 Java 线程的本质其实就是操作系统的线程**。
线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/68dc0b437827a3e863d12eba264815db_MD5.jpeg)
在Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。Solaris 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持多对多和一对一。

![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/215e702dd14a8cc1bf344509d1bd36df_MD5.jpeg)
一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区** (JDK1.8 之后的元空间)资源，但是每个线程有自己的**程序计数器**、**虚拟机栈** 和 **本地方法栈**。
> 程序计数器为什么要私有？
> 如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。
> 程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**

使用线程的方式：继承Thread类、实现Runnable接口、实现Callable接口、使用线程池、使用CompletableFuture类
==创建线程的唯一方式就是new Thread().start()创建==，不管那种方式，最终还是依赖于此。

线程的生命周期和状态？
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/c1a30c6e664efa4ffea05b927dddf6ca_MD5.jpeg)
READY到RUNNING需要获得CPU时间片。
> 在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 **RUNNABLE（运行中）** 状态 。
> 为什么JVM没有区分这两种状态？
> 现在都是RR时间片轮转，并且时间片很小，状态切换太快，没有必要区分这两个状态。

Thread#sleep方法和Object#wait方法的对比？
**共同点**：两者都可以暂停线程的执行。
**区别**：
- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

为什么wait方法不定义在Thread中？
wait是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。
**为什么 `sleep()` 方法定义在 `Thread` 中？**
因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

可以直接调用Thread类的run方法吗？
**调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

为什么要使用多线程？
总体上：
线程轻量，切换和调度成本低；多核CPU时代，多个线程可以同时运行；
多线程机制可以提高系统的并发能力
底层：
单核时代多线程是为了提高单进程利用CPU和IO系统的效率。
多核时代多线程为了提高进程利用多核CPU的能力。

单核CPU支持Java多线程吗？
支持，OS通过RR的方式，将CPU时间分配给不同的线程。
OS调度线程的方式：
- 抢占式：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。
- 协同式：线程执行完毕后，主动通知系统切换到另一个线程。
JVM 本身不负责线程的调度，而是将线程的调度委托给操作系统。操作系统通常会基于线程优先级和时间片来调度线程的执行，高优先级的线程通常获得 CPU 时间片的机会更多。

单核CPU上运行多线程效率一定高吗？
区分任务类型：
- CPU密集型
- IO密集型
CPU密集型，多线程运行会导致频繁的线程切换，增加了系统开销；IO密集型，多线程运行可以利用CPU在等待IO的空闲时间，提高了效率；

使用多线程可能带来什么问题？
内存泄漏、死锁、线程不安全等等。

如何理解线程安全与不安全？
线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。
- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。

死锁的四个必要条件？
- **互斥条件**：该资源任意一个时刻只由一个线程占用。
- **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系。

如何检测死锁？
- 使用`jmap`、`jstack`等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:`的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用`top`、`df`、`free`等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。
- 采用 VisualVM、JConsole 等工具进行排查。

预防和避免死锁？
预防死锁，破坏死锁的产生的必要条件即可：
1. **破坏请求与保持条件**：一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

避免死锁：银行家算法

### 虚拟线程
虚拟线程在Java 21发布。
**“极轻量级、自动调度、同步写法、异步性能”**
- **单 JVM** 可创建 **数百万** 条虚拟线程，每条只占 **几百字节** 栈内存。
- 阻塞操作自动 **挂起 → 卸载 → 恢复**，不占用宝贵的 OS 线程。

## volatile关键字
变量声明为volatile，指示JVM这个变量每次使用都从主存中读取。
`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。

### 禁止指令重排序
**`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。** 如果我们将变量声明为 **`volatile`** ，在对这个变量进行读写操作的时候，会通过插入特定的 **内存屏障** 的方式来禁止指令重排序。
`Unsafe` 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：
```java
public native void loadFence();
public native void storeFence();
public native void fullFence();
```

“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”
```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
`uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：
1. 为 `uniqueInstance` 分配内存空间
2. 初始化 `uniqueInstance`
3. 将 `uniqueInstance` 指向分配的内存地址
但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。

### volatile能保证原子性吗？
**`volatile` 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。**
```java
/**
 * 微信搜 JavaGuide 回复"面试突击"即可免费领取个人原创的 Java 面试手册
 *
 * @author Guide哥
 * @date 2022/08/03 13:40
 **/
public class VolatileAtomicityDemo {
    public volatile static int inc = 0;

    public void increase() {
        inc++;
    }

    public static void main(String[] args) throws InterruptedException {
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        VolatileAtomicityDemo volatileAtomicityDemo = new VolatileAtomicityDemo();
        for (int i = 0; i < 5; i++) {
            threadPool.execute(() -> {
                for (int j = 0; j < 500; j++) {
                    volatileAtomicityDemo.increase();
                }
            });
        }
        // 等待1.5秒，保证上面程序执行完成
        Thread.sleep(1500);
        System.out.println(inc);
        threadPool.shutdown();
    }
}
```
inc++是复合操作，包含三步：
1. 读取 inc 的值。
2. 对 inc 加 1。
3. 将 inc 的值写回内存。
volatile无法保证这三个操作的原子性。
利用 `synchronized`、`Lock`或者`AtomicInteger`都可以保证以上正确执行
使用synchronized改进：
```java
public synchronized void increase(){
	inc++;
}
```
使用AtomicInteger改进
```java
public AtomicInteger inc = new AtomicInteger();

public void increase(){
	inc.getAndIncrement();
}
```
使用ReentrantLock改进
```java
Lock lock = new ReentrantLock();
public void increase(){
	lock.lock();
	try{
		inc++;
	} finally{
		lock.unlock();
	}
}
```

## 乐观锁和悲观锁
什么是悲观锁？
**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。
Java 中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。
高并发场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。

什么是乐观锁？
认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。
`java.util.concurrent.atomic`包下面的原子变量类（比如`AtomicInteger`、`LongAdder`）就是使用了乐观锁的一种实现方式 **CAS** 实现的。
```java
// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好
// 代价就是会消耗更多的内存空间（空间换时间）
LongAdder sum = new LongAdder();
sum.increment();
```
高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。  
不过，大量失败重试的问题也是可以解决的，像我们前面提到的 `LongAdder`以空间换时间的方式就解决了这个问题。
理论上说：
- 悲观锁适合写多场景，可以避免频繁失败和重复影响性能。如果乐观锁解决了频繁失败和重试的问题，可以乐观锁（例如LongAdder）。
- 乐观锁适合读多写少场景，可以避免频繁加锁影响性能。但乐观锁主要针对的对象是单个共享变量（juc包下的atomic里的原子变量类）。
