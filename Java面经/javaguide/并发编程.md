## 线程
JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。由于绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核），在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。
用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。
**现在的 Java 线程的本质其实就是操作系统的线程**。
线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/68dc0b437827a3e863d12eba264815db_MD5.jpeg)
在Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。Solaris 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持多对多和一对一。

![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/215e702dd14a8cc1bf344509d1bd36df_MD5.jpeg)
一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区** (JDK1.8 之后的元空间)资源，但是每个线程有自己的**程序计数器**、**虚拟机栈** 和 **本地方法栈**。
> 程序计数器为什么要私有？
> 如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。
> 程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**

使用线程的方式：继承Thread类、实现Runnable接口、实现Callable接口、使用线程池、使用CompletableFuture类
==创建线程的唯一方式就是new Thread().start()创建==，不管那种方式，最终还是依赖于此。

线程的生命周期和状态？
![](Java%E9%9D%A2%E7%BB%8F/javaguide/attachments/c1a30c6e664efa4ffea05b927dddf6ca_MD5.jpeg)
READY到RUNNING需要获得CPU时间片。
> 在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 **RUNNABLE（运行中）** 状态 。
> 为什么JVM没有区分这两种状态？
> 现在都是RR时间片轮转，并且时间片很小，状态切换太快，没有必要区分这两个状态。

Thread#sleep方法和Object#wait方法的对比？
**共同点**：两者都可以暂停线程的执行。
**区别**：
- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

为什么wait方法不定义在Thread中？
wait是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。
**为什么 `sleep()` 方法定义在 `Thread` 中？**
因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

可以直接调用Thread类的run方法吗？
**调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

为什么要使用多线程？
总体上：
线程轻量，切换和调度成本低；多核CPU时代，多个线程可以同时运行；
多线程机制可以提高系统的并发能力
底层：
单核时代多线程是为了提高单进程利用CPU和IO系统的效率。
多核时代多线程为了提高进程利用多核CPU的能力。

单核CPU支持Java多线程吗？
支持，OS通过RR的方式，将CPU时间分配给不同的线程。
OS调度线程的方式：
- 抢占式：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。
- 协同式：线程执行完毕后，主动通知系统切换到另一个线程。
JVM 本身不负责线程的调度，而是将线程的调度委托给操作系统。操作系统通常会基于线程优先级和时间片来调度线程的执行，高优先级的线程通常获得 CPU 时间片的机会更多。

单核CPU上运行多线程效率一定高吗？
区分任务类型：
- CPU密集型
- IO密集型
CPU密集型，多线程运行会导致频繁的线程切换，增加了系统开销；IO密集型，多线程运行可以利用CPU在等待IO的空闲时间，提高了效率；

使用多线程可能带来什么问题？
内存泄漏、死锁、线程不安全等等。

如何理解线程安全与不安全？
线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。
- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。

死锁的四个必要条件？
- **互斥条件**：该资源任意一个时刻只由一个线程占用。
- **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系。

如何检测死锁？
- 使用`jmap`、`jstack`等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:`的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用`top`、`df`、`free`等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。
- 采用 VisualVM、JConsole 等工具进行排查。

预防和避免死锁？
预防死锁，破坏死锁的产生的必要条件即可：
1. **破坏请求与保持条件**：一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

避免死锁：银行家算法

### 虚拟线程
虚拟线程在Java 21发布。
**“极轻量级、自动调度、同步写法、异步性能”**
- **单 JVM** 可创建 **数百万** 条虚拟线程，每条只占 **几百字节** 栈内存。
- 阻塞操作自动 **挂起 → 卸载 → 恢复**，不占用宝贵的 OS 线程。

## volatile关键字
