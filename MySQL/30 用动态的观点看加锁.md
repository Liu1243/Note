加锁规则，**这个规则中，包含了两个“原则”、两个“优化”和一个“bug”：**
- 原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
- 原则2：查找过程中访问到的对象才会加锁。
- 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
- 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
- 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

## 不等号条件里的等值查询
```sql
begin; 
select * from t where id>9 and id<12 order by id desc for update;
```
这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和(10, 15)，id=15这一行，并没有被加上行锁，是因为优化2，next-key lock退化为了间隙锁(10,15)。
但是，我们的查询语句中where条件是大于号和小于号，这里的“等值查询”又是从哪里来的呢？
索引示意图如下：
![](MySQL/attachments/fa7d1d6617973283bed5d8478388980c_MD5.jpeg)
1. 首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id<12的值”。
2. 这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了(10,15)这个间隙。
3. 然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id=5这一行，所以会加一个next-key lock (0,5]。
也就是说，在执行过程中，==通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。==

## 等值查询的过程
```sql
begin;
select id from t where c in(5,20,10) lock in share mode;
```
explain结果是：
![](MySQL/attachments/2f41c8e42c7f7635650874e4c3fffd19_MD5.jpeg)
这条in语句使用了索引c并且rows=3，说明这三个值都是通过B+树搜索定位的。
 查找c=5的时候，先锁住了(0,5]，因为c不是唯一索引，为了确认还有没有别的记录c=5，就要向右遍历，找到c=10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。
执行c=10这个逻辑的时候，加锁的范围是(5,10] 和 (10,15)；执行c=20这个逻辑的时候，加锁的范围是(15,20] 和 (20,25)。
在索引c上加的三个记录锁的顺序是：先加c=5的记录锁，再加c=10的记录锁，最后加c=20的记录锁。

如果同时有另外一个语句执行，会产生死锁：
```sql
select id from t where c in(5,20,10) order by c desc for update;
```
由于语句里面是order by c desc， 这三个记录锁的加锁顺序，是先锁c=20，然后c=10，最后是c=5。
也就是说，这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，就可能出现死锁。

这里，我们可以得到两个结论：
1. 由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；
2. 在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以InnoDB选择了回滚成本更小的lock in share mode语句，来回滚。

## 如何看待锁等待？
![](MySQL/attachments/c0d69113969e0b2b6bb0dbc0dc20dfe2_MD5.jpeg)
session A的加锁范围是(5,10) (10,15] (15,20)
由于delete操作把id=10这一行删除了，原来的两个间隙锁(5,10) (10,15)变成了一个(5,15)。
==也就是说，所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。==

## update的例子
![](MySQL/attachments/324649dd76cb6091e91061429be2e56e_MD5.jpeg)
session A的加锁范围是索引c上的 (5,10]、(10,15]、(15,20]、(20,25]和(25,supremum]。
之后session B的第一个update语句，要把c=5改成c=1，你可以理解为两步：
1. 插入(c=1, id=5)这个记录；
2. 删除(c=5, id=5)这个记录。
按照我们上一节说的，索引c上(5,10)间隙是由这个间隙右边的记录，也就是c=10定义的。所以通过这个操作，session A的加锁范围变成了图7所示的样子：
![](MySQL/attachments/7dfa7b93de10a380d50f9b6bc5ac2556_MD5.jpeg)
好，接下来session B要执行 update t set c = 5 where c = 1这个语句了，一样地可以拆成两步：
- 插入(c=5, id=5)这个记录；
- 删除(c=1, id=5)这个记录。
第一步试图在已经加了间隙锁的(1,10)中插入数据，所以就被堵住了。

## 问题
上面我们提到一个很重要的点：所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。
那么，一个空表有间隙吗？这个间隙是由谁定义的？你怎么验证这个结论呢？
答案：
一个空表就一个间隙。
```sql
begin; 
select * from t where id>1 for update;
```
这个查询语句加锁的范围就是next-key lock (-∞, supremum]。
验证方法：
![](MySQL/attachments/12d8b3a7b90f6ca6202c2c2cef08c777_MD5.jpeg)
![](MySQL/attachments/dc6567f90ae295f43f8731e6befbe7fd_MD5.jpeg)