传统的HA架构不能预防误删数据，主库的drop table会通过binlog传给所有从库和级联从库，导致整个集群实例都执行这个命令。
对MySQL误删数据的分类：
1. 使用delete语句误删数据行；
2. 使用drop table或者truncate table语句误删数据表；
3. 使用drop database语句误删数据库；
4. 使用rm命令误删整个MySQL实例。

## 误删行
如果delete删除了数据行，可以使用Flashback工具通过闪回把数据恢复。
Flashback原理是修改binlog的内容，拿回原库重放，前提是确保binlog_format=row 和 binlog_row_image=FULL
> “ROW 格式决定‘记行’，FULL 镜像决定‘记整行’；想要**零误差复制 + 随时闪回**，就选 `ROW + FULL`，但得接受日志最胖。”

具体恢复数据时，对单个事务做如下处理：
1. 对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；
2. 同理，对于delete语句，也是将Delete_rows event改为Write_rows event；
3. 而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。
==不建议直接在主库上执行上述命令==
恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。

**我们不止要说误删数据的事后处理办法，更重要是要做到事前预防**。我有以下两个建议：
1. 把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。
2. 代码上线前，必须经过SQL审计。

设置sql_sage_updates=on后如果还要删除数据怎么办？
where id>=0
但是，delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，你应该优先考虑使用truncate table或者drop table命令。

使用truncate、drop table、drop database删除的数据，是无法使用 Flashback恢复的；因为，即使我们配置了binlog_format=row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate/drop 语句，这些信息是恢复不出数据的。

## 误删库、表
这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog。
恢复数据的流程如下：
1. 取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；
2. 用备份恢复出一个临时库；
3. 从日志备份里面，取出凌晨0点之后的日志；
4. 把这些日志，除了误删除数据的语句外，全部应用到临时库。
![](MySQL/attachments/b4528db44396c9145719e22ab26ffd37_MD5.jpeg)
---
1. 为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。 
2. 在应用日志的时候，需要跳过12点误操作的那个语句的binlog：
    - 如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用–stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日志继续执行；
    - 如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next=gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。
但速度还是不够快：
- 误删表，最好只恢复出这个表，但是mysqlbinlog工具并不能指定只解析一个表的日志。
- mysqlbinlog解析出日志应用，应用的过程只能是单线程。并行复制的方法这里使用不上。

==一种加速的方法是==，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：
1. 在start slave之前，先通过执行﻿  
    ﻿change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表；
2. 这样做也可以用上并行复制技术，来加速整个数据恢复过程。
![](MySQL/attachments/c22054b335bec713fd41ec6a4d280802_MD5.jpeg)
可以看到，图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库中。
不论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方式。
==这两种方案都要求备份系统定期备份全量日志，确保binlog从本地删除前已经备份==
但一个系统不可能备份无限的日志，需要根据成本和磁盘空间资源，设定一个日志保留的天数。
建议将数据恢复功能做成自动化工具：
- 出现误删时间，快速恢复数据，损失最小化
- 防止误操作，对业务造成二次伤害

## 延迟复制备库
虽然可以使用并行复制加速恢复数据的过程，但存在“恢复时间不可控”问题。
MySQL5.6引入**搭建延迟复制的备库**。
延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N命令，可以指定这个备库持续保持跟主库有N秒的延迟。
比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。

## 预防误删库、表的方法
第一个建议：==账号分离==。避免写错命令
- 我们只给业务开发同学DML权限，而不给truncate/drop权限。而如果业务开发人员有DDL需求的话，也可以通过开发管理系统得到支持。
- 即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。
第二个建议，==指定操作规范==。避免写错要删除的表名。
- 在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。
- 改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。

## rm删除数据
HA机制的MySQL集群不怕rm删除数据。只要不是恶意的删除整个集群，HA就会选出新的主库，保证集群的正常工作。
这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。
当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。
应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。
