## 全表扫描对server层的影响
```sql
mysql -h$host -P$port -u$user -p$pwd -e "select * from db1.t" > $target_file
```
InnoDB的数据是保存在主键索引上的，全表扫描实际上是扫描表的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。
服务端并不需要保存完整的结果集，流程是：
1. 获取一行，写到net_buffer中。这块内存的大小是由参数net_buffer_length定义的，默认是16k。
2. 重复获取行，直到net_buffer写满，调用网络接口发出去。
3. 如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。
4. 如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。
![](MySQL/attachments/05ed74ac50815649b3e9482f678d9fc5_MD5.jpeg)
在查询过程中，占用MySQL内部内存最大就是net_buffer_length这么大。
socket send buffer 也不可能达到200G（默认定义/proc/sys/net/core/wmem_default），如果socket send buffer被写满，就会暂停读数据的流程。

==MySQL是边读边发的==，客户端接收的慢，会导致MySQL服务端结果发不出去，事务执行时间变长。
![](MySQL/attachments/92cd377feb8aa08bbc3a3a2f118f6f56_MD5.jpeg)
如果你看到State的值一直处于“Sending to client”，就表示服务器端的网络栈写满了。

> -quick参数，会使用mysql_use_reslut方法，读一行处理一行
> **对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。**

如果MySQL很多线程都处于“Sending to client”状态，需要评估返回这么多结果是否合理。
而如果要快速减少处于这个状态的线程的话，将net_buffer_length参数设置为一个更大的值是一个可选方案。

与“Sending to client”长相很类似的一个状态是“Sending data”，并不一定是指“正在发送数据”，而可能是处于执行器过程中的任意阶段。

## 全表扫描对InnoDB的影响
在之前，WAL机制，InnoDB内存的作用是保存更新的结果，配合redo log避免随机写盘。
内存的数据页是在Buffer Pool (BP)中管理的，在WAL里Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。
而Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：**内存命中率**。
一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在99%以上。
![](MySQL/attachments/6489ad305cd9a9e6fafbac4c24268677_MD5.jpeg)
InnoDB Buffer Pool的大小是由参数 innodb_buffer_pool_size确定的，一般建议设置成可用物理内存的60%~80%。
InnoDB内存管理用的是最近最少使用 (Least Recently Used, LRU)算法，这个算法的核心就是淘汰最久未使用的数据。
![](MySQL/attachments/df60b92ec198462f73b1c9f38ce7ba24_MD5.jpeg)
如果要做全表扫描，那么会把当前Buffer Pool里的数据全部淘汰，存入扫描过程中访问到的数据页的内容。
对于一个正在做业务服务的库，会导致内存命中率急剧下降，磁盘压力增加，SQL语句响应变慢。
因此，InnoDB对LRU算法进行了改进：
![](MySQL/attachments/ff2eb3947082399aa263f96290e2df41_MD5.jpeg)
按照5:3的比例把整个LRU链表分成了young区域和old区域。
改进后的LRU算法执行流程变成了下面这样。
1. 图7中状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。
2. 之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但是新插入的数据页Px，是放在LRU_old处。
3. 处于old区域的数据页，每次被访问的时候都要做下面这个判断：
    - 若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；
    - 如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_time控制的。其默认值是1000，单位毫秒。

全表扫描过程中，对于一个数据页的扫描时间不会超过1s，因此会被保留在old区域，很快被淘汰出去。保证在全表扫描的过程中，对young区域无影响，保证了Buffer Pool响应正常业务的查询命中率。

## 问题
如果由于客户端压力太大，迟迟不能接收结果，会导致MySQL无法发送结果而影响语句执行。但，这还不是最糟糕的情况。
你可以设想出由于客户端的性能问题，对数据库影响更严重的例子吗？或者你是否经历过这样的场景？你又是怎么优化的？
答案：
> 造成了长事务
> - 如果前面的语句有更新，意味着它们在占用着行锁，会导致别的语句更新被锁住；
> - 当然读的事务也有问题，就是会导致undo log不能被回收，导致回滚段空间膨胀。


