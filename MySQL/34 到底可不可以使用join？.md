在实际生产中，关于join语句使用的问题，一般会集中在以下两类：
1. 我们DBA不让使用join，使用join有什么问题呢？
2. 如果有两个大小不同的表做join，应该用哪个表做驱动表呢？

## Index Nested-loop Join
语句
`select * from t1 straight_join t2 on (t1.a=t2.a);`
直接使用join，MySQL优化器可能选择t1或t2作为驱动表，这里直接使用straight_join，t1是驱动表，t2是被驱动表。
![](MySQL/attachments/608c5fb693a727f2263ef12d1317f3c2_MD5.jpeg)
被驱动表t2的字段a上有索引，join过程用上了这个索引，执行流程：
1. t1中读一行数据R
2. 从数据行R中取出a字段到t2中寻找
3. 取出t2中满足条件的行，跟R组成一行，作为结果集的一部分
4. 重复执行，直到t1的末尾循环结束
过程是遍历t1，根据t1取出每行数据的a，去t2查找满足条件的记录。形式上，与嵌套参训类似，并且可以使用被驱动表的索引，称之为“Index Nested-Loop Join”，简称NLJ。
![](MySQL/attachments/900a3c53b5524ae9fe413041129b533d_MD5.jpeg)
流程中：
- 对驱动表t1做了全表扫描
- 对于每一行R，根据a字段去t2查，走的树搜索过程。
**能不能使用join?**
不使用join的流程：
- 执行`select * from t1;`，查出t1所有数据
- 循环遍历t1所有数据：
	- 每一行R中取出a
	- 执行`select * from t2 where a = #a;`
	- 返回结果和R构成结果集的一行
比直接join多了很多次交互
**怎么选择驱动表？**
在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。
假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。
假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。
因此整个执行过程，近似复杂度是 N + N*2*log2M。
==显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。==

到这里小结一下，通过上面的分析我们得到了两个结论：
1. 使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好；
2. 如果使用join语句的话，需要让小表做驱动表。
结论的前提是“可以使用被驱动表的索引”

## Simple Nested-Loop Join
语句：
`select * from t1 straight_join t2 on (t1.a=t2.b);`
由于表t2的字段b上没有索引，因此再用图2的执行流程时，每次到t2去匹配的时候，就要做一次全表扫描。

当然，MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称BNL。

## Block Nested-Loop Join
这时候，被驱动表上没有可用的索引，算法的流程是这样的：
1. 把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；
2. 扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。
![](MySQL/attachments/475842be4759939ae20d126374d6ca7d_MD5.jpeg)
SQL语句的explain结果如下：
![](MySQL/attachments/efcf025599fc4843642850bb94913da8_MD5.jpeg)
可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100\*1000=10万次。
但是相比于Simple Nested-Loop join算法相比，Block Nested-Loop Join算法判断实在内存中，速度快。

假设小表的行数是N，大表的行数是M，那么在这个算法里：
1. 两个表都做一次全表扫描，所以总的扫描行数是M+N；
2. 内存中的判断次数是M\*N。
可以看到，调换这两个算式中的M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。

如果t1也是大表，join_buffer放不下怎么办？
join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。**如果放不下表t1的所有数据话，策略很简单，就是分段放。**
执行：
`select * from t1 straight_join t2 on (t1.a=t2.b);`
扫描过程：
1. 扫描t1，顺序读入join-buffer中，放到88行join_buffer满了
2. 扫描t2，把t2中的每一行取出，跟join_buffer相比，满足join条件的，作为结果集的一部分返回
3. 清空join_buffer
4. 继续扫描t1，顺序读取最后的12行数据放入join_buffer中，继续第二步
![](MySQL/attachments/b59c6b955c237140bad2c0be44d266bd_MD5.jpeg)
图中的步骤4和5，表示清空join_buffer再复用。

我们再来看下，在这种情况下驱动表的选择问题。
假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。
注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，显然λ的取值范围是(0,1)。
所以，在这个算法的执行过程中：
1. 扫描行数是 N+λ*N*M；
2. 内存判断 N\*M次。
显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。
==应该让小标当驱动表==
当然，你会发现，在N+λ*N*M这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好。
刚刚我们说了N越大，分段数K越大。那么，N固定的时候，什么参数会影响K的大小呢？（也就是λ的大小）答案是join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。
这就是为什么，你可能会看到一些建议告诉你，==如果你的join语句很慢，就把join_buffer_size改大。==

第一个问题：能不能使用join语句？
1. 如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；
2. 如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。
所以你在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现“Block Nested Loop”字样。

第二个问题是：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？
1. 如果是Index Nested-Loop Join算法，应该选择小表做驱动表；
2. 如果是Block Nested-Loop Join算法：
    - 在join_buffer_size足够大的时候，是一样的；
    - 在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。

**在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。**

## 总结：
1. 如果可以使用被驱动表的索引，join语句还是有其优势的；
2. 不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句就尽量不要使用；
3. 在使用join的时候，应该让小表做驱动表。
