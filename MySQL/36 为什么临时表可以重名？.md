临时表有哪些特征，为什么它适合这个场景？
- 内存表，指的是使用Memory引擎的表，建表语法是create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。
- 而临时表，可以使用各种引擎类型 。如果是使用InnoDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用Memory引擎。

## 临时表的特性
![](MySQL/attachments/ead9ecdccab5c6de2faea955c04c6e9b_MD5.jpeg)
1. 建表语法是create temporary table …。
2. 一个临时表只能被创建它的session访问，对其他线程不可见。所以，图中session A创建的临时表t，对于session B就是不可见的。
3. 临时表可以与普通表同名。
4. session A内有同名的临时表和普通表的时候，show create语句，以及增删改查语句访问的是临时表。
5. show tables命令不显示临时表。

由于临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表。也正是由于这个特性，**临时表就特别适合我们文章开头的join优化这种场景**。
- 不用session临时表可以重名，如果多个session同时join优化，不需要担心表名重复导致建表失败
- 不需要担心数据删除问题。

## 临时表应用
由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。

为什么临时表可以重名？
执行`create temporary table temp_t(id int primary key)engine=innodb;`
MySQL会给这个InnoDB表创建一个frm文件保存表结构定义。这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程id}\_{线程id}\_序列号”。你可以使用select @@tmpdir命令，来显示实例的临时文件目录。
而关于表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：
- 在5.6以及之前的版本里，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文件，用来存放数据文件；
- 而从 5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建ibd文件了。
从文件名的前缀规则，可以看到创建临时表与创建普通表是不同的。

MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。
- 一个普通表的table_def_key的值是由“库名+表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现table_def_key已经存在了。
- 而对于临时表，table_def_key在“库名+表名”基础上，又加入了“server_id+thread_id”。
sessionA和sessionB创建的两个临时表，table_def_key不同，磁盘文件名也不同，可以并存。

在实现上，每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE +表名”操作。
可以观察到binlog中也记录了DROP TEMPORARY TABLE命令，这与主备复制有关。

## 临时表和主备复制
主库执行：
```sql
create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/ 
create temporary table temp_t like t_normal;/*Q2*/ 
insert into temp_t values(1,1);/*Q3*/ 
insert into t_normal select * from temp_t;/*Q4*/
```
如果关于临时表的操作不记录，那么备库就会报错“表temp_t不存在”。
如果当前的binlog_format=row，那么跟临时表有关的语句，就不会记录到binlog里。也就是说，只在binlog_format=statment/mixed 的时候，binlog中才会记录临时表的操作。

**还有另外一个问题需要解决**：主库上不同的线程创建同名的临时表是没关系的，但是传到备库执行是怎么处理的呢？
![](MySQL/attachments/053911743f27851a656859c60b71f5dc_MD5.jpeg)
MySQL在记录binlog的时候，会把主库执行这个语句的线程id写到binlog中。这样，在备库的应用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key：
1. session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid”+“session A的thread_id”;
2. session B的临时表t1，在备库的table_def_key就是 ：库名+t1+“M的serverid”+“session B的thread_id”。
由于table_def_key不同，所以这两个表在备库的应用线程里面是不会冲突的。

## 小结
在实际应用中，临时表一般用于处理比较复杂的计算逻辑。由于临时表是每个线程自己可见的，所以不需要考虑多个线程执行同一个处理逻辑时，临时表的重名问题。在线程退出的时候，临时表也能自动删除，省去了收尾和异常处理的工作。
在binlog_format='row’的时候，临时表的操作不记录到binlog中，也省去了不少麻烦，这也可以成为你选择binlog_format时的一个考虑因素。
临时表也分为：用户临时表和内部临时表。

## 问题
下面的语句序列是创建一个临时表，并将其改名：
![](MySQL/attachments/7b3fb69c0c57cfec8a9b12eb2f7a183c_MD5.jpeg)
可以看到，我们可以使用alter table语法修改临时表的表名，而不能使用rename语法。你知道这是什么原因吗？
答案：
> 在实现上，执行rename table语句的时候，要求按照“库名/表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的frm文件是放在tmpdir目录下的，并且文件名的规则是“#sql{进程id}_{线程id}_序列号.frm”，因此会报“找不到文件名”的错误。

