sort buffer、内存临时表、join buffer这三个数据结构都是用来存放语句执行过程中的中间数据，辅助SQL的执行。排序的时候使用sort buffer、join的时候使用join buffer。
下面介绍需要用到内部临时表的两个例子。

## union执行流程
建表：
`create table t1(id int primary key, a int, b int, index(a));`
执行：
`(select 1000 as f) union (select id from t1 order by id desc limit 2);`
explain
![](MySQL/attachments/4250594b8a1e8fda6339fcca7c32c235_MD5.jpeg)
key=PRIMARY使用索引id
Extra=Using Temporary 使用临时表
执行流程：
1. 创建内存临时表，只有一个字段f，是主键字段
2. 执行第一个子查询，1000插入
3. 第二个子查询：1000插入失败，999插入成功
4. 临时表取出数据，返回结果，删除临时表，数据包括1000和999
![](MySQL/attachments/8cf667abebb95e644f669a4407b11d58_MD5.jpeg)
内存临时表暂存数据，并使用临时表主键id的唯一性约束，实现了union的语义。
如果使用union all，就没有“去重”的语义，那么执行的过程中就直接得到的结果作为结果集返回客户端，不需要临时表。
![](MySQL/attachments/c975f9bedfca5699673cc582e1e5f370_MD5.jpeg)
Extra=Using index，只使用了覆盖索引，没有临时表。

## group by执行流程
`select id%10 as m, count(*) as c from t1 group by m;`
![](MySQL/attachments/aeb273ea5eb478f1fb029a6737f5c7a6_MD5.jpeg)
Extra：Using index使用覆盖索引a，不需要回表；Using temporary使用临时表；Using filesort需要排序；
![](MySQL/attachments/fcdcc31b65ea16909e8f788a31ff5be3_MD5.jpeg)
最后一步就是对内存临时表的排序。
![](MySQL/attachments/a15c151aac807f3d6a826c819133892a_MD5.jpeg)
执行结果是：
![](MySQL/attachments/6364926cfd89495251257420962ba9ad_MD5.jpeg)
如果不需要对结果进行排序，增加order by null
`select id%10 as m, count(*) as c from t1 group by m order by null;`
跳过最后的排序阶段，直接从临时表中取数据返回。
![](MySQL/attachments/9a410931df7bb925a333109bfc1dac87_MD5.jpeg)
表t1的id是从1开始的，因此结果集中第一行是id=1
内存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。
如果执行：
```sql
set tmp_table_size=1024;
select id%100 as m, count(*) as c from t1 group by m order by null limit 10;
```
内存临时表会达到上限，内存临时表会转成磁盘临时表，默认使用的引擎是InnoDB。
![](MySQL/attachments/18471f8856081a76028ac6622e54e732_MD5.jpeg)

### group by优化方法 -- 索引
不论使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表。
执行group by语句为什么需要临时表？
group by的语义逻辑，是统计不同的值出现的个数。但是执行的结果是无序的，所以需要一个临时表，记录并统计结果。
如果能保证出现的数据是有序的，那么就不需要临时表了。
![](MySQL/attachments/a5f97ea3a70007829aeb1176273e0f29_MD5.jpeg)
可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右，顺序扫描，依次累加。
按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时表，也不需要再额外排序。
InnoDB的索引，可以满足这个输入有序的条件。
MySQL 5.7版本支持了generated column机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列z，然后在z列上创建一个索引（如果是MySQL 5.6及之前的版本，你也可以创建普通列和索引，来解决这个问题）
`alter table t1 add column z int generated always as(id % 100), add index(z);`
这样，索引z上的数据就是有序的，语句改写为：
`select z, count(*) as c from t1 group by z;`
![](MySQL/attachments/e7edbabd4981d01148c7bf59b9bae901_MD5.jpeg)
Extra看出 不需要临时表，也不需要排序

### group by优化方法 -- 直接排序
如果遇到不适合创建索引的场景，就只能做排序。
一个group by语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”。
MySQL有没有让我们直接走磁盘临时表的方法呢？
在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。
磁盘临时表使用B+树存储，存储效率不如数组。
`select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;`
![](MySQL/attachments/bb4c9aac79fb4f609c990cce8191691c_MD5.jpeg)
![](MySQL/attachments/16b7e234d146b9466e7c54bc258460d0_MD5.jpeg)
从Extra看出，没有使用临时表，而是直接使用了排序算法。

MySQL什么时候会使用内部临时表？
1. 如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；
2. join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；
3. 如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union需要用到唯一索引约束， group by还需要用到另外一个字段来存累积计数。

## 小结
1. 如果对group by语句的结果没有排序要求，要在语句后面加 order by null；
2. 尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort；
3. 如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；
4. 如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法得到group by的结果。

## 问题
文章中图8和图9都是order by null，为什么图8的返回结果里面，0是在结果集的最后一行，而图9的结果里面，0是在结果集的第一行？
答案：
> 