## 内存表的数据组织结构
InnoDB的主键索引是B+树，数据就放在主键索引树上。聚簇索引结构
![](MySQL/attachments/77aa7769ecc143063c651da52cf5f91e_MD5.jpeg)
Memory引擎的数据和索引是分开的。
![](MySQL/attachments/e395c6f00e6f28af2db66b84ee011bcd_MD5.jpeg)
主键id索引里，存放的是每个数据的位置，主键id是hash索引。索引上的key并不是有序的。

可见，InnoDB和Memory引擎的数据组织方式是不同的：
- InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。这种方式，我们称之为**索引组织表**（Index Organizied Table）。
- 而Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为**堆组织表**（Heap Organizied Table）。

从中我们可以看出，这两个引擎的一些典型不同：
1. InnoDB表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；
2. 当数据文件有空洞的时候，InnoDB表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；
3. 数据位置发生变化的时候，InnoDB表只需要修改主键索引，而内存表需要修改所有索引；（索引存放的都是数据行的地址）
4. InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。
5. InnoDB支持变长数据类型，不同记录的长度可能不同；内存表不支持Blob 和 Text字段，并且即使定义了varchar(N)，实际也当作char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。

Memory表的主键索引是hash索引，如果要执行范围查询，是用不上主键索引的，需要走全表扫描。
## hash索引和B-Tree索引
内存表也支持B-Tree索引。
`alter table t1 add index a_btree_index using btree (id);`
数据组织形式就变成了：
![](MySQL/attachments/495d73f63f9f29572ed3b339f83fe209_MD5.jpeg)
内存表速度快的原因：
1. Memory引擎支持hash索引
2. 数据都保存在内存，内存读写比磁盘快

==不建议在生产环境中使用内存表==，原因：
1. 锁粒度问题
2. 数据持久化问题

## 内存表的锁
内存表不支持行锁，只支持表锁。跟行锁比起来，表锁对并发访问的支持不够好。所以，内存表的锁粒度问题，决定了它在处理并发事务的时候，性能也不会太好。

## 数据持久性问题
数据库重启的时候，所有的内存表都会被清空。

**M-S架构下，使用内存表存在的问题**
![](MySQL/attachments/fe30f66f0e57783cb1f71916b3aaef6a_MD5.jpeg)
时序：
1. 业务正常访问主库
2. 备库升级重启，内存表t1清空
3. 备库重启后，客户端发送update语句，修改t1的数据行，备库应用线程会报错“找不到要更新的行”
这是主备同步停止。如果发生主备切换，表t1数据会“丢失”。

担心主库重启之后，出现主备不一致，MySQL在实现上做了这样一件事儿：在数据库重启之后，往binlog里面写入一行DELETE FROM t1。
**如果是双M结构**
![](MySQL/attachments/627d0749b0c8f6cfc715f5fd7fee2749_MD5.jpeg)
在备库重启的时候，备库binlog里的delete语句就会传到主库，然后把主库内存表的内容删除。这样你在使用的时候就会发现，主库的内存表数据突然被清空了。

1. 如果你的表更新量大，那么并发度是一个很重要的参考指标，InnoDB支持行锁，并发度比内存表好；
2. 能放到内存表的数据量都不大。如果你考虑的是读的性能，一个读QPS很高并且数据量不大的表，即使是使用InnoDB，数据也是都会缓存在InnoDB Buffer Pool里的。因此，使用InnoDB表的读性能也不会差。
==建议把普通内存表都用InnoDB表替代==

在数据量可控，不会耗费过多内存的情况下，你可以考虑使用内存表。也就是说内存临时表：
1. 临时表不会被其他线程访问，没有并发性的问题；
2. 临时表重启后也是需要删除的，清空数据这个问题不存在；
3. 备库的临时表也不会影响主库的用户线程。

前面join优化当时使用的是InnoDB临时表，语句是：
```sql
create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;
insert into temp_t select * from t2 where b>=1 and b<=2000; 
select * from t1 join temp_t on (t1.b=temp_t.b);
```
这里使用内存临时表的好处是：
1. 相比于InnoDB表，使用内存表不需要写磁盘，往表temp_t的写数据的速度更快；
2. 索引b使用hash索引，查找的速度比B-Tree索引快；
3. 临时表数据只有2000行，占用的内存有限。
优化为：
```sql
create temporary table temp_t(id int primary key, a int, b int, index(b))engine=memory;
insert into temp_t select * from t2 where b>=1 and b<=2000; 
select * from t1 join temp_t on (t1.b=temp_t.b);
```
不论是导入数据的时间，还是执行join的时间，使用内存临时表的速度都比使用InnoDB临时表要快。

## 问题
假设你刚刚接手的一个数据库上，真的发现了一个内存表。备库重启之后肯定是会导致备库的内存表数据被清空，进而导致主备同步停止。这时，最好的做法是将它修改成InnoDB引擎表。
假设当时的业务场景暂时不允许你修改引擎，你可以加上什么自动化逻辑，来避免主备同步停止呢？
答案：
> 主库暂时不能修改引擎，就把备库的内存表引擎改成InnoDB
> set sql_log_bin=off;
> alter table tbl_name engine=innodb;
> 避免备库重启的时候，数据丢失问题。
> 由于主库重启后，会往binlog里面写“delete from tbl_name”，这个命令传到备库，备库的同名的表数据也会被清空。因此，就不会出现主备同步停止的问题。
> 如果由于主库异常重启，触发了HA，这时候我们之前修改过引擎的备库变成了主库。而原来的主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据）都改成InnoDB表。所以，如果我们不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内存表就把引擎改了。
> 同时，跟业务开发同学约定好建表规则，避免创建新的内存表。
