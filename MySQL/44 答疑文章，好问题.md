## join的写法
1. 如果用left join的话，左边的表一定是驱动表吗？
2. 如果两个表的join包含多个条件的等值匹配，是都要写到on里面呢，还是只把一个条件写到on里面，其他条件写到where部分？
构造两个表a、b：
```sql
create table a(f1 int, f2 int, index(f1))engine=innodb; 
create table b(f1 int, f2 int)engine=innodb; 
insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6); 
insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);
```
写法为：
```sql
select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q1*/ 
select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/
```
执行结果：
![](MySQL/attachments/e9e731bc8eb2e3917e0cd8fada60b44d_MD5.jpeg)
Q1包含表a所有行，Q2仅包含满足条件的行。
Q1的explain结果：
> explain中id相同的第一行是驱动表
![](MySQL/attachments/cbb6cd6c0b0fa21de6e05a9f0d899822_MD5.jpeg)
- 驱动表是a，被驱动表是b
- 表b的f1字段没有索引，使用BNL算法
执行流程：
1. 表a读入join_buffer。因为是select \*，所以f1、f2都放入join_buffer
2. 顺序扫描表b，判断join条件是否满足，满足条件的记录作为结果集的一行返回。如果有where子句，先判断where是否满足条件，再返回。
3. 表b扫描完成后，对于没有被匹配的表a的行（在这个例子中就是(1,1)、(2,2)这两行），把剩余字段补上NULL，再放入结果集中。
![](MySQL/attachments/1914a17f12f14d0fc4c2c323593981a5_MD5.jpeg)
以表a作为驱动表，执行效果和straight_join是一样的。

Q2的explain结果：
![](MySQL/attachments/7991bce6c3eb5350fc856c4e1522e58e_MD5.jpeg)
Extra字段什么都没写，使用的是NLJ算法。
使用b作为驱动表，语句Q2的执行流程是这样的：顺序扫描表b，每一行用b.f1到表a中去查，匹配到记录后判断a.f2=b.f2是否满足，满足条件的话就作为结果集的一部分返回。

**为什么语句Q1和Q2这两个查询的执行流程会差距这么大呢？**
优化器基于Q2这个查询的语义做了优化。
语句Q2里面where a.f2=b.f2就表示，查询结果里面不会包含b.f2是NULL的行，这样这个left join的语义就是“找到这两个表里面，f1、f2对应相同的行。对于表a中存在，而表b中匹配不到的行，就放弃”。
语义和join一致。优化器就把这条语句的left join改写成了join，然后因为表a的f1上有索引，就把表b作为驱动表，这样就可以用上NLJ 算法。
执行show warnings，看到改写结果：
![](MySQL/attachments/f6bda2dc3eac9af2be94c4fda988471b_MD5.jpeg)
**使用left join时，左边的表不一定是驱动表。**
**如果需要left join的语义，就不能把被驱动表的字段放在where条件里面做等值判断或不等值判断，必须都写在on里面。**

在join语句的情况下：
```sql
select * from a join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q3*/
select * from a join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q4*/
```
两个语句都被改写为：
```sql
select * from a join b where (a.f1=b.f1) and (a.f2=b.f2);
```
执行计划一模一样。在这种情况下，join将判断条件是否全放在on部分没有区别。

## Simple Nested Loop Join性能问题
虽然BNL算法和Simple Nested Loop Join 算法都是要判断M\*N次（M和N分别是join的两个表的行数），但是Simple Nested Loop Join 算法的每轮判断都要走全表扫描，因此性能上BNL算法执行起来会快很多。
BNL算法的执行逻辑是：
1. 首先，将驱动表的数据全部读入内存join_buffer中，这里join_buffer是无序数组；
2. 然后，顺序遍历被驱动表的所有行，每一行数据都跟join_buffer中的数据进行匹配，匹配成功则作为结果集的一部分返回。
Simple Nested Loop Join算法的执行逻辑是：顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。
Simple Nested Loop Join算法也是把数据读到内存里，然后进行匹配，为什么性能差距这么大？
3. 在对被驱动表做全表扫描的时候，如果数据没有在Buffer Pool中，就需要等待这部分数据从磁盘读入；从磁盘读入数据到内存中，会影响正常业务的Buffer Pool命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部
4. 1. 即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而join_buffer中是数组，遍历的成本更低。
==总之，BNL算法性能更好==

## distinct和group by的性能
如果只需要去重，不需要执行聚合函数，distinct 和group by哪种效率高一些呢？
表t的字段a上没有索引：
```sql
select a from t group by a order by null; 
select distinct a from t;
```
标准的group by语句是需要聚合函数count的：
`select a,count(*) from t group by a order by null;`
这条语句的逻辑是：按照字段a分组，计算每组的a出现的次数。在这个结果里，由于做的是聚合计算，相同的a只出现一次。
没有了count(\*)之后，第一条语句的逻辑就变成是：按照字段a做分组，相同的a的值只返回一行。而这就是distinct的语义，所以不需要执行聚合函数时，distinct 和group by这两条语句的语义和执行流程是相同的，因此执行性能也相同。
这两条语句的执行流程是下面这样的。
1. 创建一个临时表，临时表有一个字段a，并且在这个字段a上创建一个唯一索引；
2. 遍历表t，依次取数据插入临时表中：
    - 如果发现唯一键冲突，就跳过；
    - 否则插入成功；
3. 遍历完成后，将临时表作为结果集返回给客户端。

## 备库自增主键问题
在binlog_format=statement时，语句A先获取id=1，然后语句B获取id=2；接着语句B提交，写binlog，然后语句A再写binlog。这时候，如果binlog重放，是不是会发生语句B的id为1，而语句A的id为2的不一致情况呢？
> 自增id的生成顺序，和binlog的写入顺序可能是不同的

这个问题限定在statement格式下，也是对的。因为row格式的binlog就没有这个问题了，Write row event里面直接写了每一行的所有字段的值。
```sql
create table t(id int auto_increment primary key); 
insert into t values(null);
```
![](MySQL/attachments/7601eba4176c3b2e3728ed3b364c9cf2_MD5.jpeg)
在insert语句之前，还有一句SET INSERT_ID=1，这个线程里下一次需要用到自增值的时候，不论当前表的自增值是多少，固定用1这个值。

最终的binlog是：
```sql
SET INSERT_ID=2; 
语句B； 
SET INSERT_ID=1; 
语句A；
```
即使两个INSERT语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。

## 思考
他查看了一下innodb_trx，发现这个事务的trx_id是一个很大的数（281479535353408），而且似乎在同一个session中启动的会话得到的trx_id是保持不变的。当执行任何加写锁的语句后，trx_id都会变成一个很小的数字（118378）。
你可以通过实验验证一下，然后分析看看，事务id的分配规则是什么，以及MySQL为什么要这么设计呢？
答案：
> - InnoDB 的 **事务 ID（trx_id）只有在事务第一次需要写入/加锁**（更新、插入、删除，或 `SELECT … FOR UPDATE/LOCK IN SHARE MODE` 这类**锁定读**）时才真正分配。
> - 在此之前，事务是“纯读（read-only）”状态，**不会占用真正的 trx_id**；在 `information_schema.innodb_trx` 里会显示一个**很大的“虚拟 ID”**，大约在 **2^48（=281,474,976,710,656）以上**。
> - 一旦发生写或锁定读，事务被升级为读写事务，**立即从全局计数器拿到真正的、较小且单调递增的 trx_id**（比如 118378），因此你看到的 ID 立刻“变小”。

