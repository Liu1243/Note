> 笔记内容为学习极客时间-MySQL实战45讲

## 01 基础架构：一条SQL查询语句是如何执行的？
MySQL的基本架构示意图如下图所示：
![](MySQL/attachments/34ac5e67995e7afd46d6dd53414567d9_MD5.jpeg)
大体上，可以分为Server层和存储层两部分。
**Server层**包括连接器、分析器、优化器、执行器以及查询缓存，包括MySQL大多数核心功能，以及所有的内置函数（日期、时间、数字等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器以及视图等。
**存储引擎层**负责数据的存储以及提取。架构模式是插件式的，支持innoDB、MyISAM、Memory等多个存储引擎。目前最常用的是InnoDB，从5.5.5版本开始成为默认的存储引擎。
下面是各个组件的作用：
**连接器** 连接器负责跟客户端建立连接、获取权限、维持和管理连接。
连接默认使用长连接，这可能会导致MySQL长时间后内存占用过大，被系统强行Kill，现象来看就是MySQL异常重启。
解决方案：
>1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存大的查询后，断开连接，之后要查询再重连。
>2. 如果使用5.7或者更新的版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和做权限验证，但会将连接恢复到刚刚创建完时的状态。

**查询缓存** 是一个保存在内存中，KV形式的缓存
但通常==不建议使用查询缓存==，因为查询缓存弊大于利。
对于更新压力大的数据库来说，查询缓存的命中率非常低；除非是对一个静态表，很长时间才会更新一次，才适合使用查询缓存。
MySQL可以将参数`query_cache_type`设置为DEMAND，这样对于默认的SQL语句都不使用查询缓存，对于确定要使用查询缓存的语句，可以使用SQL_CACHE显式指定
`select SQL_CACHE * from T where ID=10；`
MySQL8.0版本中将查询缓存的整个功能模块都删除了。

**分析器** 包括 *词法分析* 以及 *语法分析*

**优化器** 优化器式在表中有多个索引的情况下，决定使用哪个索引；或者是在一个语句有多表关联（join）的时候，决定表的连接顺序。

**执行器** 执行器用于执行最终优化好的SQL语句。
执行器的执行流程为：
1. 首先判断用户对该表的权限
2. 调用定义的存储引擎的接口获取该表的第一行，判断条件，如果不是则跳过，如果是将该行保存到结果集中
3. 调用引擎结果取“下一行”，重复判断逻辑，直到该表的最后一行
4. 执行器将上述遍历过程中所有满足条件的行组成记录集作为结果集返回给客户端
可以在数据库的慢查询日志中看到`rows_examined`字段，表示语句执行过程中扫描了多少行。在有些场景下，执行器调用一次，在存储引擎内部扫描多行，所以==引擎扫描行数和rows_examined并不是完全相同的==

问题：
> 我给你留一个问题吧，如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？

答案： 