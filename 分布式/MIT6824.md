## 01 Introduction
### 分布式底层基础架构：
- Storage，存储基础架构，比如键值服务器、文件系统等
- Computation，计算框架，用来编排或构件分布式应用程序，比如经典的mapreduce
- Comminication，分布式系统逃不开网络通信问题，比如后续会讨论的RPC(远程过程调用)
RPC提供的语义：
- **at most once：最多一次**
- **exactly once：恰好一次**
- **at least once：至少一次**

分布式系统的3个重要特性：
**fault tolerance 容错性：**
包括可用性，用p999指标度量，依赖replication
可恢复性，依赖logging 或者 transaction 以及 durable storage

**consistency 一致性**：
强一致性、最终一致性

**performance 性能**：
throughout 吞吐量
latency 低延迟，避免尾部延迟（一台机器执行慢，拖慢整个请求响应）

==需要做到一致性与性能的权衡==

### MapReduce
具体参考：[mp.weixin.qq.com/s/I0PBo\_O8sl18O5cgMvQPYA](https://mp.weixin.qq.com/s/I0PBo_O8sl18O5cgMvQPYA)
![](%E5%88%86%E5%B8%83%E5%BC%8F/attachments/d4fa0b3b50f4a3ecd6d958ed899ba97a_MD5.jpeg)
**工作流：**
1. 将输入文件分成M个小文件，集群启动MapReduce实例，包括一个Master和多个Worker
2. Master分配任务，将Map任务分配给Worker节点
3. Map Worker读取文件，执行用户定义的map函数，输出key、value，缓存在内存中
4. 内存中的key、value通过partitioning function分为R个regions，写入磁盘，将文件地址回传给Master，Master将地址传给Reduce Worker
5. Reduce Worker收到文件位置信息，通过RPC获取数据，根据key排序，将同一key的数据分组聚合
6. Reduce Worker将分组后的值执行用户自定义的reduce函数，输出追加到所属分区的输出文件中
7. 当所有Map、Reduce任务完成后，Master向用户程序返回结果
**实例：**
词频统计

**容错性**：
Worker故障：Master向Worker发送心跳包，指定时间内没返回，标记为Worker失效，将任务分配给其他Worker
Master故障：终止子整个MapReduce任务，重新执行

**性能**：
**网络带宽匮乏**：尽量将Map任务分配给包含输入数据的机器上执行，如果找不到，就近分配
**“落伍者（Stragglers）”**：单点机器执行慢，通过备用任务（backup tasks）处理，Master调度其他进程同时处理该任务，其中一个执行完成， 就标记为任务完成。

**Combiner函数**：
在某些情况下，Map函数产生的中间key值重复数据多，用户可以自定义一个Combiner函数，先将本地的记录进行一次合并，然后再将合并的结果通过网络发送出去。
![](%E5%88%86%E5%B8%83%E5%BC%8F/attachments/d80f085916fe694320c83ab33b53f2b0_MD5.jpeg)
==Combiner函数通常和Reduce函数的代码相同，使用Combiner的好处是减少网络的通信量==
为什么默认禁用Combiner？
Combiner与Reducer一个是本地聚合，一个是全局聚合，逻辑会有偏差，会影响到执行结果的正确性。

## 02 RPC and Threads
参考：[微信公众平台](https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&mid=2247484193&idx=1&sn=693e0ff4bfcc6e02dea10ed9d639b41b&chksm=970980e4a07e09f2647de63ed0bf3be98d9032a3797033af3872c692d2373f98627a63f30e22&cur_album_id=1751707148520112128&scene=189#wechat_redirect)
Go通过channel、sync.Cond、WaitGroup解决线程问题。
GO RPC实现了==At Most Once==语义，如果没有得到响应，只会返回一个错误。客户端可以重试一个失败请求，服务端需要处理重复请求的情况：
- 如何保证多个客户端的 ID 是唯一的？可以带上客户端 ID，类似于：`<client_id, seq>`(和 Raft 客户端交互那部分内容对应上了！)
- 但我们不可能无期限地保存所有的请求 ID，保存多长时间？可以在客户端的请求中包含一个额外的标识符 X，告诉服务端删除 X 之前的所有请求 ID 是安全的
- 当原始请求还在执行时，如何处理重复的请求？可以等待它完成，也可以直接忽略新的请求。
- 为了避免服务器宕机，ID 信息还需要写入到磁盘，也许还要跨机器多副本存储。

## 03 GFS
参考：[mp.weixin.qq.com/s?\_\_biz=MzIwODA2NjIxOA==&mid=2247484205&idx=1&sn=ff45aeaeac29b79a6fad53f912a16933&chksm=970980e8a07e09feebe17c4cde354cd3caf1432ea0897ba4db7d08f05ffe245ec46773e36fb9&cur\_album\_id=1751707148520112128&scene=189#wechat\_redirect](https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&mid=2247484205&idx=1&sn=ff45aeaeac29b79a6fad53f912a16933&chksm=970980e8a07e09feebe17c4cde354cd3caf1432ea0897ba4db7d08f05ffe245ec46773e36fb9&cur_album_id=1751707148520112128&scene=189#wechat_redirect)

### GFS的目标
- 大型：大容量，需要存放大量的数据集；
- 性能：自动分片(Auto-Sharding)；
- 全局：不只是为一个应用而定制，适用于各种不同的应用；
- 容错：自动容错，不希望每次服务器出了故障，都要手动去修复；
### 架构
![](%E5%88%86%E5%B8%83%E5%BC%8F/attachments/61e85453876b90e37c380a2d7298b277_MD5.jpeg)
GFS集群包含一个master和多个chunkserver，并且有多个client进行交互

