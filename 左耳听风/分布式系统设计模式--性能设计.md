## 缓存
分布式系统中最耗性能的是后端数据库，一般insert、update和delete不会出现性能问题。
绝大多数情况，select会出现性能问题。一方面，select 会有很多像 join、group、order、like 等这样丰富的语义；另一方面，大多数应用都是读多写少，所以加剧了慢查询的问题。
使用缓存是非常必要的事情。

缓存的三种模式：

### Cache Aside更新模式
最常用的设计模式。
	失效：应用程序先从 Cache 取数据，如果没有得到，则从数据库中取数据，成功后，放到缓存中。
	命中：应用程序从 Cache 中取数据，取到后返回。
	更新：先把数据存到数据库中，成功后，再让缓存失效。
为什么不是写完数据库后更新缓存？主要是怕两个并发的写操作导致脏数据。
要么通过 2PC 或是 Paxos 协议保证一致性，要么就是拼命地降低并发时脏数据的概率。而 Facebook 使用了这个降低概率的玩法，因为 2PC 太慢，而 Paxos 太复杂。当然，最好还是为缓存设置好过期时间。

### Read/Write Through更新模式
Read/Write Through 套路是把更新数据库（repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。应用认为后端就是一个单一的存储，而存储自己维护自己的 Cache。

Read Through
Read Through 套路就是在查询操作中更新缓存

Write Through
命中了缓存，则更新缓存，然后由 Cache 自己更新数据库（同步操作）

### Write Behind Caching更新模式
Write Behind 又叫 Write Back。与Linux文件系统的page cache算法一样。
Write Back 套路就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的 I/O 操作飞快无比（因为直接操作内存嘛）。因为异步，Write Back 还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。
但数据不是强一致性的，而且可能会丢失。
Write Back 实现逻辑比较复杂，因为它需要 track 有哪些数据是被更新了的，需要刷到持久层上。

### 缓存设计的重点
缓存是通过牺牲强一致性来提高性能的，使用缓存的时候，一般会使用 LRU 策略。LRU 在读写时都需要加锁（除非是单线程无并发），因此 LRU 可能会导致更慢的缓存存取的时间。这点要小心。

## 异步处理
异步通讯在分布式系统中还可以增加整个系统的吞吐量，从而可以面对更高的并发，并可以从容地利用好现有的系统资源。
==这就是异步系统所带来的好处——让我们的系统可以统一调度。==

### 异步处理的设计
异步通讯讲的是怎么把系统连接起来，而异步处理处理的是任务。
我们收到请求后，给客户端返回“收到请求，正在处理中”。然后，我们有个任务处理系统来真正地处理收到的这些请求。为了解耦，我们需要一个任务派发器，这里就会出来两个事，一个是推模型 Push，一个是拉模型 Pull。
一般来说，Push 模型可以做调度，但是它需要知道下游工作结点的情况。而 Pull 的好处则是可以让上游结点不用关心下游结点的状态，只要自己忙得过来，就会来拿任务处理，这样可以减少一定的复杂度，但是少了整体任务调度。
一般来说，我们构建的都是推拉结合的系统，Push 端会做一定的任务调度，比如它可以像物流那样把相同商品的订单都合并起来，打成一个包，交给下游系统让其一次处理掉；也可以把同一个用户的订单中的不同商品给拆成多个订单。然后 Pull 端来订阅 Push 端发出来的异步消息，处理相应的任务。

### 事件溯源
所谓 Event Sourcing，其主要想解决的问题是，我们可以看到数据库中的一个数据的值（状态），但我们完全不知道这个值是怎么得出来的。
只需要追加不可修改的数据操作事件，而不是保存最终状态。除了可以提高性能和响应时间之外，还可以提供事务数据一致性，并保留了可以启用补偿操作的完整记录和历史记录。
事件不可变，并且可使用只追加操作进行存储。 用户界面、工作流或启动事件的进程可继续，处理事件的任务可在后台异步运行。 此外，处理事务期间不存在争用，这两点可极大提高应用程序的性能和可伸缩性。
事件溯源不需要直接更新数据存储中的对象，因而有助于防止并发更新造成冲突。
最重要的是，异步处理 + 事件溯源的方式，可以很好地让我们的整个系统进行任务的统筹安排、批量处理，可以让整体处理过程达到性能和资源的最大化利用。
关于 Event Sourcing 一般会和 CQRS 一起提。
需要做snapshot，否则系统重启重放日志太恐怖。

> CQRS（Command Query Responsibility Segregation）核心思想：
> - 将 **命令（Command）** 与 **查询（Query）** 的责任分离。
> - **命令端**（写模型）：处理写操作，通常结合 Event Sourcing 只负责产生事件，不直接更新数据库。
> - **查询端**（读模型）：基于事件流或者快照，异步更新一个专门的查询数据库，用来支持高性能的读取。

### 异步处理的分布式事务
对于分布式事务，在强一致性下，在业务层上只能做两阶段提交，而在数据层面上需要使用 Raft/Paxos 的算法。但是，我想说，在现实生活中，需要用到强一致性的场景实在不多，不是所有的场景都必须要强一致性的事务的。
异步的方式可以达到最终一致性。在达成这个事务的过程中，有几点需要注意：
	凭证需要非常好地保存起来，不然会导致事务做不下去。
	凭证处理的幂等性问题，不然在重试时就会出现多次交易的情况。
	如果事务完成不了，需要做补偿事务处理。

### 异步处理的设计要点
异步处理中的事件驱动和事件溯源是两个比较关键的技术。
异步处理可能会因为一些故障导致我们的一些任务没有被处理，比如消息丢失，没有通知到，或通知到了，没有处理。有这一系列的问题，需要接收方回复ack。
发起方有定时器，对超时未ack的任务重新发起。要求接收方支持幂等性处理。
异步处理整体业务事务，如果失败需要回滚，需要走补偿事务的流程。
并不是所有的业务都可以用异步的方式，比如一些需要强一致性的业务，使用异步的方式可能就不适合，这里需要我们小心地分析业务。
在运维时，我们要监控任务队列里的任务积压情况。如果有任务积压了，要能做到快速地扩容。如果不能扩容，而且任务积压太多，可能会导致整个系统挂掉，那么就要开始对前端流量进行限流。
异步处理系统的本质是把被动的任务处理变成主动的任务处理，其本质是在对任务进行调度和统筹管理。