## 分布式锁
分布式系统的锁服务，一般可以使用DB、Redis和ZooKeeper实现。分布式锁服务的特点是：
	安全性（Safety）：在任意时刻，只有一个客户端可以获得锁（排他性）。
	避免死锁：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。
	容错性：只要锁服务集群中的大部分节点存活，Client 就可以进行加锁解锁操作。

### Redis分布式锁服务
通过下述命令对资源加锁：
`SET resource_name my_random_value NX PX 30000`
	my_random_value 必须是全局唯一的值。这个随机数在释放锁时保证释放锁操作的安全性。
	SET NX 命令只会在 key 不存在的时候给 key 赋值，PX 命令通知 Redis 保存这个 key 30000ms。
	获得锁的客户端如果没有在这个时间窗口内完成操作，就可能会有其他客户端获得锁，引起争用问题。
获取锁的原理就是：
只有在某个 key 不存在的情况下才能设置（set）成功该 key。于是，这就可以让多个进程并发去设置同一个 key，只有一个进程能设置成功。而其它的进程因为之前有人把 key 设置成功了，而导致失败（也就是获得锁失败）。
锁解锁通过lua脚本：
```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
	return redis.call("del",KEYS[1])
else
	return 0
end
```
通过这个方式释放锁是为了避免 Client 释放了其他 Client 申请的锁。

关于 value 的生成，官方推荐从 /dev/urandom 中取 20 个 byte 作为随机数。或者采用更加简单的方式，例如使用 RC4 加密算法在 /dev/urandom 中得到一个种子（Seed），然后生成一个伪随机流。
也可以采用更简单的方法，使用时间戳 + 客户端编号的方式生成随机数。Redis 的官方文档说：“这种方式的安全性较差一些，但对于绝大多数的场景来说已经足够安全了”。

### 分布式锁服务的一个问题
Redis的分布式锁存在问题：Redis通过超时释放锁，但是存在这样一个场景
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/30a2bd8b301028884bccd995d1d1a977_MD5.jpeg)
最后Client A会将Client B的更新覆盖。

要解决这个问题，引入fence栅栏技术，也就是乐观锁机制，通过版本号排他。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/6e473cf311cd39397fc15baacb7c7215_MD5.jpeg)
- 锁服务需要有一个单调递增的版本号。
- 写数据的时候，也需要带上自己的版本号。
- 数据库服务需要保存数据的版本号，然后对请求做检查。
如果使用ZooKeeper做分布式锁服务，可以使用zxid或znode的版本号做这个fence版本号。

### 从乐观锁到CAS
如果在数据库中存储版本号，那么完全可以使用数据库来做分布式锁服务。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/3c8439c29d51746ca6318aa1ba2475a6_MD5.jpeg)
使用数据版本（Version）记录机制，即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现的。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加一。
当我们提交更新的时候，数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对。如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。
==如果使用版本号，或者fence token的方式，就不需要使用分布式锁服务==
这种 fence token 的玩法，在数据库那边一般会用 timestamp 时间截来玩。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。

有时候都不需要在数据库中增加额外的版本字段或fence token。例如想更新库存，直接对比select时库存量与需要update时的库存量进行对比，如果一致则update。这也就是CAS操作。
**从分布式锁到乐观锁，再到CAS，我们还需要分布式锁服务吗？**

### 分布式锁设计的重点
一般情况下，我们可以使用数据库、Redis 或 ZooKeeper 来做分布式锁服务，这几种方式都可以用于实现分布式锁。
分布式锁的特点是，保证在一个集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。这就是所谓的分布式互斥。所以，大家在做某个事的时候，要去一个服务上请求一个标识。如果请求到了，我们就可以操作，操作完后，把这个标识还回去，这样别的进程就可以请求到了。
分布式锁的初衷和概念性问题：
	获取锁的进程挂掉了怎么办？会导致死锁，一般是加过期时间。
	如果锁自动释放了，新进程拿到锁了，之前进程还有锁怎么办？像 Redis 那样也可以使用 Check and Set 的方式来保证数据的一致性。
	如果通过像 CAS 这样的操作的话，我们还需要分布式锁服务吗？但现实生活中也有不需要更新某个数据的场景，只是为了同步或是互斥一下不同机器上的线程，这时候像 Redis 这样的分布式锁服务就有意义了。
我是用来修改某个共享源的，还是用来不同进程间的同步或是互斥的。如果使用 CAS 这样的方式（无锁方式）来更新数据，那么我们是不需要使用分布式锁服务的，而后者可能是需要的。==所以，这是我们在决定使用分布式锁服务前需要考虑的第一个问题——我们是否需要？==
如果确定使用分布式锁服务，需要考虑：
	需要给一个锁被释放的方式，以避免请求者不把锁还回来，导致死锁的问题。Redis通过超时时间，ZooKeeper通过sessionTimeout删除节点。
	分布式锁服务应该是HA的，并且需要持久化。
	要提供非阻塞方式的锁服务。
	还要考虑锁的可重入性。
Redis 也是不错的，ZooKeeper 在使用起来需要有一些变通的方式，好在 Apache 有 Curator 帮我们封装了各种分布式锁的玩法。

> Apache Curator是对ZK的封装。
> **Curator**：由 Netflix 开发，后来捐给 Apache，提供了更高层次的抽象，解决了 ZK 的常见坑，并内置了很多 **recipes（模式/工具类）**。
> 在HA上，和 Redis RedLock 不同，Curator 的锁是基于 **ZooKeeper 的强一致性协议（ZAB 协议）** 来实现的

|特性|Redis RedLock|Curator（基于 ZK）|
|---|---|---|
|一致性|**最终一致性**（可能存在极端并发错误）|**强一致性**（ZAB 协议保证）|
|可用性|依赖多 Redis 实例，过半存活即可|依赖 ZK 集群（半数以上存活）|
|适用场景|分布式调度、缓存控制、限流等|金融、交易、强一致性要求高的业务|
|易用性|Redisson/自己实现|Curator 封装好，直接用|
|自动释放|依赖过期时间|依赖 session，断连自动清理|
### 小结
为什么需要分布式锁服务？就像单机系统上的多线程程序需要用操作系统锁或数据库锁来互斥对共享资源的访问一样，分布式程序也需要通过分布式锁来互斥对共享资源的访问。
分布式锁服务一般可以通过 Redis 和 ZooKeeper 等实现。
进一步，数据库如果本身利用 CAS 等手段支持这种版本控制方式，其实也就没必要用一个独立的分布式锁服务了。最后，我们发现，分布式锁服务还能用来做同步，这是数据库锁做不了的事情。

## 配置中心
软件会有一些配置信息，比如数据库用户名密码等，在分布式场景下，为了便于管理，会引入一个集中式的配置管理系统。

### 配置中心的设计
区分软件的配置
一种方式是把软件的配置分成静态配置和动态配置。
	所谓静态配置其实就是在软件启动时的一些配置，运行时基本不会进行修改，也可以理解为是环境或软件初始化时需要用到的配置。例如OS网络配置、Docker进程配置。
	动态配置其实就是软件运行时的一些配置，在运行时会被修改。比如，日志级别、降级开关、活动开关。
这里主要针对动态配置的管理。
动态配置有三个区分的维度：
- 按照运行环境分。开发环境、测试环境、预发环境、生产环境。
- 按照依赖区分。一种是依赖配置，一种是不依赖的内部配置。比如，外部依赖的 MySQL 或 Redis 的连接配置。还有一种完全是自己内部的配置。
- 按照层次分。就像云计算一样，配置也可以分成 IaaS、PaaS、SaaS 三层。基础层的配置是操作系统的配置，中间平台层的配置是中间件的配置，如 Tomcat 的配置，上层软件层的配置是应用自己的配置。

配置中心的模型
配置项就是key、value的模型。
IaaS层、PaaS层，也就是OS层和平台层是由专门的运维人员或者架构师配置，value应该是选项，而不是用户自由输入的，最好有相关的模板。
SaaS层，应用层的配置项，有响应的命名规范，以及命名空间，确保不同应用的配置项不会冲突。

外部服务依赖的配置应该放在服务发现系统中，而不是配置中心。这样使得语义更加清楚，也会减少因为运行不同环境导致配置不同的差异性。
对于不同运行环境中配置的差异来说，比如在开发环境和测试环境下，日志级别是 Debug 级，对于生产环境则是 Warning 或 Error 级，因为环境的不一样，会导致我们需要不同的配置项的值。
配置应该有一个整体的版本管理，每次变动将版本的差异记录下来。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/7ea666aa5321c66745e206ed6e30d6ef_MD5.jpeg)

配置中心的架构
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/f4c8885d2d2f1e0d38266865bd70287e_MD5.jpeg)
在这个图中可以看到，我们把配置录入后，配置中心发出变更通知，配置变更控制器会来读取最新的配置，然后应用配置。
	为什么需要一个变更通知的组件，而不是配置中心直接推送？分布式环境下，服务器太多，推送不太现实，而采用一个 Pub/Sub 的通知服务可以让数据交换经济一些。
	为什么不直接Pub数据过去，还要订阅方反向拉数据？直接Pub也可以。但是反向拉取的好处是API可以校验请求者的权限，而且有时候需要调用配置中心的基本API。
	配置变更控制器部署在哪里？是在每个服务器上，还是在一个中心的地方？变更配置的步骤算是一个事务，为了执行效率，建议将配置变更控制器在每个服务器都部署。
	平台层的配置变更，有的参数是在服务启动的命令行上，这个怎么变更呢？一般来说，命令行上的参数需要通过 Shell 环境变量做成配置项，然后通过更改系统环境变量，并重启服务达到配置变更。
	操作系统的配置变更和平台层的配置变更最好模块化掉，就像云服务中的不同尺寸的主机型号一样。 这样有利于维护和减少配置的复杂性。
	应用服务配置更新的标准化。主要有三种方式：SDK、运维脚本方式、Agent方式
SDK方式（开发期接入）：供一个统一的 SDK/开发框架，应用直接通过它读取配置，并支持订阅配置更新事件（observer 模式）。标准化最彻底，开发规范统一。但是耦合语言。
运维脚本方式（Ops驱动）：要求应用方提供配置变更时的运维脚本（如 `reload.sh`），平台通过控制器统一调度执行这些脚本。不耦合语言。配置变更逻辑分散在各应用，难以统一标准。并且脚本复杂容易出错。
Agent方式（Sidecar）：为每个应用部署一个 **Agent/Sidecar**，对外暴露标准 Admin API；Agent 内部再去适配不同应用的配置方式（文件修改、调用内部 API 等）。语言无关，对应用透明。需要额外运维Agent，增加应用宿主机的复杂度。

|方案|优点|缺点|适用场景|
|---|---|---|---|
|SDK|彻底标准化，开发期统一|耦合语言、改造成本高|技术栈统一，新项目建设|
|运维脚本|灵活，语言无关|脚本复杂，标准化差，易出错|老系统多，异构环境|
|Agent（Sidecar）|对外统一接口，透明，灵活落地|Agent 维护成本高|大中型公司，异构系统，需要可控扩展|

### 配置中心的设计重点
配置中心主要的用处是统一和规范化管理所有的服务配置，也算是一种配置上的治理活动。配置中心的设计重点应该放在如何统一和标准化软件的配置项，其还会涉及到软件版本、运行环境、平台、中间件等一系列的配置参数。
编程的本质是对 logic 和 control 的分离，所以，对于配置也一样，其也有控制面上的配置和业务逻辑面上的配置，控制面上的配置最好能标准统一。
配置更新的过程是一个事务，需要考虑失败回滚。
配置更新控制器，需要应用服务的配合，比如，配置的 reload，服务的优雅重启，服务的 Admin API，或是通过环境变量……这些最好是由一个统一的开发框架搞定。
配置更新控制器还担任服务启动的责任，由配置更新控制器来启动服务。这样，配置控制器会从配置中心拉取所有的配置，更新操作系统，设置好启动时用的环境变量，并更新好服务需要的配置文件 ，然后启动服务。

