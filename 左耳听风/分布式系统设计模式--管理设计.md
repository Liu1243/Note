## 分布式锁
分布式系统的锁服务，一般可以使用DB、Redis和ZooKeeper实现。分布式锁服务的特点是：
	安全性（Safety）：在任意时刻，只有一个客户端可以获得锁（排他性）。
	避免死锁：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。
	容错性：只要锁服务集群中的大部分节点存活，Client 就可以进行加锁解锁操作。

### Redis分布式锁服务
通过下述命令对资源加锁：
`SET resource_name my_random_value NX PX 30000`
	my_random_value 必须是全局唯一的值。这个随机数在释放锁时保证释放锁操作的安全性。
	SET NX 命令只会在 key 不存在的时候给 key 赋值，PX 命令通知 Redis 保存这个 key 30000ms。
	获得锁的客户端如果没有在这个时间窗口内完成操作，就可能会有其他客户端获得锁，引起争用问题。
获取锁的原理就是：
只有在某个 key 不存在的情况下才能设置（set）成功该 key。于是，这就可以让多个进程并发去设置同一个 key，只有一个进程能设置成功。而其它的进程因为之前有人把 key 设置成功了，而导致失败（也就是获得锁失败）。
锁解锁通过lua脚本：
```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
	return redis.call("del",KEYS[1])
else
	return 0
end
```
通过这个方式释放锁是为了避免 Client 释放了其他 Client 申请的锁。

关于 value 的生成，官方推荐从 /dev/urandom 中取 20 个 byte 作为随机数。或者采用更加简单的方式，例如使用 RC4 加密算法在 /dev/urandom 中得到一个种子（Seed），然后生成一个伪随机流。
也可以采用更简单的方法，使用时间戳 + 客户端编号的方式生成随机数。Redis 的官方文档说：“这种方式的安全性较差一些，但对于绝大多数的场景来说已经足够安全了”。

### 分布式锁服务的一个问题
Redis的分布式锁存在问题：Redis通过超时释放锁，但是存在这样一个场景
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/30a2bd8b301028884bccd995d1d1a977_MD5.jpeg)
最后Client A会将Client B的更新覆盖。

要解决这个问题，引入fence栅栏技术，也就是乐观锁机制，通过版本号排他。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/6e473cf311cd39397fc15baacb7c7215_MD5.jpeg)
- 锁服务需要有一个单调递增的版本号。
- 写数据的时候，也需要带上自己的版本号。
- 数据库服务需要保存数据的版本号，然后对请求做检查。
如果使用ZooKeeper做分布式锁服务，可以使用zxid或znode的版本号做这个fence版本号。

### 从乐观锁到CAS
如果在数据库中存储版本号，那么完全可以使用数据库来做分布式锁服务。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/3c8439c29d51746ca6318aa1ba2475a6_MD5.jpeg)
使用数据版本（Version）记录机制，即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现的。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加一。
当我们提交更新的时候，数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对。如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。
==如果使用版本号，或者fence token的方式，就不需要使用分布式锁服务==
这种 fence token 的玩法，在数据库那边一般会用 timestamp 时间截来玩。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。

有时候都不需要在数据库中增加额外的版本字段或fence token。例如想更新库存，直接对比select时库存量与需要update时的库存量进行对比，如果一致则update。这也就是CAS操作。
**从分布式锁到乐观锁，再到CAS，我们还需要分布式锁服务吗？**

### 分布式锁设计的重点
一般情况下，我们可以使用数据库、Redis 或 ZooKeeper 来做分布式锁服务，这几种方式都可以用于实现分布式锁。
分布式锁的特点是，保证在一个集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。这就是所谓的分布式互斥。所以，大家在做某个事的时候，要去一个服务上请求一个标识。如果请求到了，我们就可以操作，操作完后，把这个标识还回去，这样别的进程就可以请求到了。
分布式锁的初衷和概念性问题：
	获取锁的进程挂掉了怎么办？会导致死锁，一般是加过期时间。
	如果锁自动释放了，新进程拿到锁了，之前进程还有锁怎么办？像 Redis 那样也可以使用 Check and Set 的方式来保证数据的一致性。
	如果通过像 CAS 这样的操作的话，我们还需要分布式锁服务吗？但现实生活中也有不需要更新某个数据的场景，只是为了同步或是互斥一下不同机器上的线程，这时候像 Redis 这样的分布式锁服务就有意义了。
我是用来修改某个共享源的，还是用来不同进程间的同步或是互斥的。如果使用 CAS 这样的方式（无锁方式）来更新数据，那么我们是不需要使用分布式锁服务的，而后者可能是需要的。==所以，这是我们在决定使用分布式锁服务前需要考虑的第一个问题——我们是否需要？==
如果确定使用分布式锁服务，需要考虑：
	需要给一个锁被释放的方式，以避免请求者不把锁还回来，导致死锁的问题。Redis通过超时时间，ZooKeeper通过sessionTimeout删除节点。
	分布式锁服务应该是HA的，并且需要持久化。
	要提供非阻塞方式的锁服务。
	还要考虑锁的可重入性。
Redis 也是不错的，ZooKeeper 在使用起来需要有一些变通的方式，好在 Apache 有 Curator 帮我们封装了各种分布式锁的玩法。

> Apache Curator是对ZK的封装。
> **Curator**：由 Netflix 开发，后来捐给 Apache，提供了更高层次的抽象，解决了 ZK 的常见坑，并内置了很多 **recipes（模式/工具类）**。
> 在HA上，和 Redis RedLock 不同，Curator 的锁是基于 **ZooKeeper 的强一致性协议（ZAB 协议）** 来实现的

|特性|Redis RedLock|Curator（基于 ZK）|
|---|---|---|
|一致性|**最终一致性**（可能存在极端并发错误）|**强一致性**（ZAB 协议保证）|
|可用性|依赖多 Redis 实例，过半存活即可|依赖 ZK 集群（半数以上存活）|
|适用场景|分布式调度、缓存控制、限流等|金融、交易、强一致性要求高的业务|
|易用性|Redisson/自己实现|Curator 封装好，直接用|
|自动释放|依赖过期时间|依赖 session，断连自动清理|
### 小结
为什么需要分布式锁服务？就像单机系统上的多线程程序需要用操作系统锁或数据库锁来互斥对共享资源的访问一样，分布式程序也需要通过分布式锁来互斥对共享资源的访问。
分布式锁服务一般可以通过 Redis 和 ZooKeeper 等实现。
进一步，数据库如果本身利用 CAS 等手段支持这种版本控制方式，其实也就没必要用一个独立的分布式锁服务了。最后，我们发现，分布式锁服务还能用来做同步，这是数据库锁做不了的事情。

## 配置中心
