- **容错设计又叫弹力设计**，其中着眼于分布式系统的各种“容忍”能力，包括容错能力（服务隔离、异步调用、请求幂等性）、可伸缩性（有/无状态的服务）、一致性（补偿事务、重试）、应对大流量的能力（熔断、降级）。可以看到，在确保系统正确性的前提下，系统的可用性是弹力设计保障的重点。
- **管理篇**会讲述一些管理分布式系统架构的一些设计模式，比如网关方面的，边车模式，还有一些刚刚开始流行的，如Service Mesh相关的设计模式。
- **性能设计篇**会讲述一些缓存、CQRS、索引表、优先级队列、业务分片等相关的架构模式。

## 弹力设计篇之“认识故障和弹力设计”
[41 弹力设计：认识故障和弹力设计 - 极客时间文档](https://uaxe.github.io/geektime-docs/%E5%90%8E%E7%AB%AF-%E6%9E%B6%E6%9E%84/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/41%20-%20%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%AE%A4%E8%AF%86%E6%95%85%E9%9A%9C%E5%92%8C%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1/)
### 系统可用性度量
容错设计，在英文中又叫Resiliency（弹力）。意思是，系统在不健康、不顺，甚至出错的情况下有能力hold得住，挺得住，还有能在这种逆境下力挽狂澜的能力。
$$Availability=\frac{MTTF}{MTTF +MTTR}$$
- MTTF 是 Mean Time To Failure，平均故障前的时间，即系统平均能够正常运行多长时间才发生一次故障。系统的可靠性越高，MTTF越长。（注意：从字面上来说，看上去有Failure的字样，但其实是正常运行的时间。）
- MTTR 是 Mean Time To Recovery，平均修复时间，即从故障出现到故障修复的这段时间，这段时间越短越好。
这个公式就是计算系统可用性的，也就是我们常说的，多少个9
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/cbbfa8f48d00644ae2ce70f227b049a6_MD5.jpeg)
提高可用性：要么提高系统的无故障时间，要么减少系统的故障恢复时间

### 故障原因
除了软件设计，还有硬件，还有第三方服务（如电信联通的宽带SLA），当然包括“建筑施工队的挖掘机”。
SLA不只是一个技术指标，还是服务提供商和用户之间的contract，工业界中会把服务不可用的因素分为两种：
**无计划的**
- 系统级故障，包括主机、操作系统、中间件、数据库、网络、电源以及外围设备。
- 数据和中介的故障，包括人员误操作、硬盘故障、数据乱了。
- 还有自然灾害、人为破坏，以及供电问题等。
**有计划的**
- 日常任务：备份，容量规划，用户和安全管理，后台批处理应用。
- 运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护。
- 升级相关：数据库、应用、中间件、操作系统、网络，包括硬件升级。

归类就是：安全问题、性能问题、网络问题、运维问题、管理问题、硬件问题

### 故障不可避免
要意识到：
- 故障是正常的，而且是常见的。
- 故障是不可预测突发的，而且相当难缠。
不要尝试着去避免故障，而是要把处理故障的代码当成正常的功能做在架构里写在代码里。
我们要干的事儿就是想尽一切手段来降低 MTTR——故障的修复时间。
这就是为什么我们把这个设计叫做弹力（Resiliency）。
- 一方面，在好的情况下，这个事对于我们的用户和内部运维来说是完全透明的，系统自动修复不需要人的干预。
- 另一方面，如果修复不了，系统能够做自我保护，而不让事态变糟糕。

## 弹力设计篇之“隔离设计”
[42 弹力设计：隔离设计 - 极客时间文档](https://uaxe.github.io/geektime-docs/%E5%90%8E%E7%AB%AF-%E6%9E%B6%E6%9E%84/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/42%20-%20%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%EF%BC%9A%E9%9A%94%E7%A6%BB%E8%AE%BE%E8%AE%A1/)
隔离设计对应的单词是 Bulkheads，中文翻译为隔板。
一般来说，对于系统的分离有两种方式，一种是以服务的种类来做分离，一种是以用户来做分离。

### 按服务的种类做分离
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/08d6d457bd5ec035bb613fa24f667d71_MD5.jpeg)
将系统分成了用户、商品、社区三个板块。这三个块分别使用不同的域名、服务器和数据库，做到从接入层到应用层再到数据层三层完全隔离。这样一来，在物理上来说，一个板块的故障就不会影响到另一板块。
Amazon中每个服务都有自己的数据库，每个数据库中都保存着和这个业务相关的数据和相应的处理状态。而每个服务从一开始就准备好了对外暴露。同时，这也是微服务所推荐的架构方式。
存在的问题是：
- 如果我们需要同时获得多个板块的数据，那么就需要调用多个服务，这会降低性能。注意，这里性能降低指的是响应时间，而不是吞吐量（相反，在这种架构下，吞吐量可以得到提高）。
这种情况下，可以通过设计用户交互来解决。
- 如果有大数据平台，就需要把这些数据都抽取到一个数据仓库中进行计算，这也增加了数据合并的复杂度。对于这个问题，我们需要一个框架或是一个中间件来对数据进行相应的抽取。
- 另外，如果我们的业务逻辑或是业务流程需要跨板块的话，那么一个板块的故障也会导致整个流程走不下去，同样会导致整体业务故障。
- 对于这个问题，一方面，我们需要保证这个业务流程中各个子系统的高可用性，并且在业务流程上做成 Step-by-Step 的方式，这样用户交互的每一步都可以保存，以便故障恢复后可以继续执行，而不是从头执行。
- 还有，如果需要有跨板块的交互也会变得有点复杂。对此我们需要一个类似于 Pub/Sub 的高可用、且可以持久化的消息订阅通知中间件来打通各个板块的数据和信息交换。
- 最后还会有在多个板块中分布式事务的问题。对此，我们需要“二阶段提交”这样的方案。在亚马逊中，使用的是 Plan – Reserve – Commit/Cancel 模式。
隔离了的系统需要引入大量的异步处理模型。

### 按用户的请求做分离
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/6918fa2e1e7e6fc70e5e49c1864844d8_MD5.jpeg)
将用户分成不同的组，并把后端的同一个服务根据这些不同的组分成不同的实例。让同一个服务对于不同的用户进行冗余和隔离，这样一来，当服务实例挂掉时，只会影响其中一部分用户，而不会导致所有的用户无法访问。
这种分离可以和按功能的分离进行融合。就是所谓的“多租户”模式。对于一些比较大的客户，我们可以为他们设置专门独立的服务实例，或是服务集群与其他客户隔离开来，对于一些比较小的用户来说，可以让他们共享一个服务实例，这样可以节省相关的资源。
通常来说多租户的做法有三种。
- 完全独立的设计。每个租户有自己完全独立的服务和数据。
- 独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。
- 共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/12b308acb5aff2f13a54459222b87e95_MD5.jpeg)
- 如果使用完全独立的方案，在开发实现上和资源隔离度方面会非常好，然而，成本会比较高，计算资源也会有一定的浪费。
- 如果使用完全共享的方案，在资源利用和成本上会非常好，然而，开发难度非常大，而且数据和资源隔离非常不好。
一般来说，技术方案会使用折中方案，也就是中间方案，服务是共享的，数据通过分区来隔离，而对于一些比较重要的租户（需要好的隔离性），则使用完全独立的方式。
在虚拟化技术成熟的今天，我们完全可以使用“完全独立”（完全隔离）的方案，通过底层的虚拟化技术（Hypervisor 的技术，如 KVM，或是 Linux Container 的技术，如 Docker）来实现物理资源的共享和成本的节约。

### 隔离设计的重点
1. 定义隔离业务的大小和粒度
2. 无论是系统板块还是多租户的隔离，需要考虑系统的复杂度、成本、性能以及资源使用情况。
3. 隔离模式需要配置一些高可用、重试、异步、消息中间件，流控、熔断等设计模式的方式配套使用。
4. 需要自动化运维工具
5. 服务监控系统

## 弹力设计篇之“异步通讯设计”
隔离设计需要对系统做解耦设计，把一个单体系统解耦，不单单是把业务功能拆分出来，正如前面所说，拆分完后还会面对很多的问题。其中一个重要的问题就是这些系统间的通讯。
通讯一般来说分同步和异步两种。
同步调用虽然让系统间只耦合于接口，而且实时性也会比异步调用要高，但是我们也需要知道同步调用会带来如下几个问题：
- 同步调用需要被调用方的吞吐不低于调用方的吞吐。否则会被慢的一方拖死，整个同步调用链的性能会由最慢的服务决定
- 同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。在并发比较高的场景下，等待会极度消耗资源
- 同步调用只能是一对一的，很难做到一对多。
- 同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。
异步相较于同步来说，可以增加系统的吞吐量，还可以让服务间解耦，统的调用方和被调用方可以按照自己的速率而不是步调一致，从而可以更好地保护系统，让系统更有弹力。

### 异步通讯的三种方式
请求响应式
发送方（sender）会直接请求接收方（receiver），被请求方接收到请求后，直接返回——收到请求，正在处理。
对于返回结果，有两种方法，一种是发送方时不时地去轮询一下，问一下干没干完。另一种方式是发送方注册一个回调方法，也就是接收方处理完后回调请求方。
这种情况下还是有一定耦合的。是发送方依赖于接收方，并且要把自己的回调发送给接收方，处理完后回调。

发布订阅的方式
接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。
送方并不关心订阅方的处理结果，它只是告诉订阅方有事要干，收完消息后给个 ACK 就好了，你干成啥样我不关心。
请求响应式的方式有数据状态的往来，所以服务是有状态的。如果我们把服务的状态给去掉（通过第三方的状态服务来保证），那么服务间的依赖就只有事件了。
分布式系统的服务设计是需要向无状态服务（Stateless）努力的，这其中有太多的好处，无状态意味着你可以非常方便地运维。所以，事件通讯成为了异步通讯中最重要的一个设计模式。
在这种方式下，接收方需要向发送方订阅事件，所以是接收方依赖于发送方。这种方式还是有一定的耦合。

通过Broker的方式
所谓 Broker，就是一个中间人，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。如下图所示。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/adb5745595c13d48293435bab91de43b_MD5.jpeg)
这是完全的解耦。所有的服务都不需要相互依赖，而是依赖于一个中间件 Broker。这个 Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。
但是所有人都依赖于一个总线，这个总线需要有如下的特性：
- 必须是高可用的，因为它成了整个系统的关键；
- 必须是高性能而且是可以水平扩展的；
- 必须是可以持久化不丢数据的。

事件驱动设计
发布订阅和通过Broker的方式都是事件驱动架构（EDA – Event Driven Architecture）。
事件驱动最好是使用 Broker 方式，服务间通过交换消息来完成交流和整个流程的驱动。
如下图所示，这是一个订单处理流程。下单服务通知订单服务有订单要处理，而订单服务生成订单后发出通知，库存服务和支付服务得到通知后，一边是占住库存，另一边是让用户支付，等待用户支付完成后通知配送服务进行商品配送。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/380cbe70e19a932fbe978ba787f5a873_MD5.jpeg)
每个服务都是“自包含”的，没有和别人产生依赖。而要把整个流程给串联起来，我们需要一系列的“消息通道（Channel）”。各个服务做完自己的事后，发出相应的事件，而又有一些服务在订阅着某些事件来联动。
事件驱动的好处：
- 服务间的依赖没有了，服务间是平等的，每个服务都是高度可重用并可被替换的。
- 服务的开发、测试、运维，以及故障处理都是高度隔离的。
- 服务间通过事件关联，所以服务间是不会相互 block 的。
- 在服务间增加一些 Adapter（如日志、认证、版本、限流、降级、熔断等）相当容易。
- 服务间的吞吐也被解开了，各个服务可以按照自己的处理速度处理。
事件驱动的缺点是：
- 业务流程不再那么明显和好管理。整个架构变得比较复杂。解决这个问题需要有一些可视化的工具来呈现整体业务流程。
- 事件可能会乱序。这会带来非常 Bug 的事。解决这个问题需要很好地管理一个状态机的控制。
- 事务处理变得复杂。需要使用两阶段提交来做强一致性，或是退缩到最终一致性。

### 异步通讯的设计重点
为什么要异步通讯：
- 异步通讯最重要的是解耦服务间的依赖。最佳解耦的方式是通过 Broker 的机制。
- 解耦的目的是让各个服务的隔离性更好，这样不会出现“一倒倒一片”的故障。
- 异步通讯的架构可以获得更大的吞吐量，而且各个服务间的性能不受干扰相对独立。
- 利用 Broker 或队列的方式还可以达到把抖动的吞吐量变成均匀的吞吐量，这就是所谓的“削峰”，这对后端系统是个不错的保护。
- 服务相对独立，在部署、扩容和运维上都可以做到独立不受其他服务的干扰。
设计异步通讯的时候需要注意：
- 用于异步通讯的中间件 Broker 成为了关键，需要设计成高可用不丢消息的。另外，因为是分布式的，所以可能很难保证消息的顺序，因此你的设计最好不依赖于消息的顺序。
- 异步通讯会导致业务处理流程不那么直观，因为像接力一样，所以在 Broker 上需要有相关的服务消息跟踪机制，否则出现问题后不容易调试。
- 因为服务间只通过消息交互，所以业务状态最好由一个总控方来管理，这个总控方维护一个业务流程的状态变迁逻辑，以便系统发生故障后知道业务处理到了哪一步，从而可以在故障清除后继续处理。
> 	这样的设计常见于银行的对账程序，银行系统会有大量的外部系统通讯，比如跨行的交易、跨企业的交易，等等。所以，为了保证整体数据的一致性，或是避免漏处理及处理错的交易，需要有对账系统，这其实就是那个总控，这也是为什么银行有的交易是 T+1（隔天结算），就是因为要对个账，确保数据是对的。
- 消息传递中，可能有的业务逻辑会有像 TCP 协议那样的 send 和 ACK 机制。比如：A 服务发出一个消息之后，开始等待处理方的 ACK，如果等不到的话，就需要做重传。此时，需要处理方有幂等的处理，即同一条消息无论收到多少次都只处理一次。

### 小结
同步调用的问题：影响吞吐量、消耗系统资源、只能一对一、有多米诺骨牌效应。可以使用异步调用来避免这些问题。
异步调用的方式：请求响应、发布订阅、Broker订阅。

## 弹力设计篇之“幂等性设计”
所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。
为什么我们需要这样的操作？说白了，就是在我们把系统解耦隔离后，服务间的调用可能会有三个状态，一个是成功（Success），一个是失败（Failed），一个是超时（Timeout）。前两者都是明确的状态，而超时则是完全不知道是什么状态。
因为系统超时，而调用方重试一下，会给我们的系统带来不一致的副作用。
这种情况下，有两种处理方式：
- 一种是需要下游系统提供相应的查询接口。上游系统在 timeout 后去查询一下。如果查到了，就表明已经做了，成功了就不用做了，失败了就走失败流程。
- 另一种是通过幂等性的方式。也就是说，把这个查询操作交给下游系统，我上游系统只管重试，下游系统保证一次和多次的请求结果是一样的。
第一种方式，需要对方提供一个查询接口配合。而第二种方式则需要下游的系统提供支持幂等性的交易接口。

### 全局ID
要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易。
如果由一个中心系统来分配，那么每一次交易都需要找那个中心系统来。 这样增加了程序的性能开销。如果由上游系统来分配，则可能会出现 ID 分配重复的问题。因为上游系统可能会是一个集群，它们同时承担相同的工作。
为了解决分配冲突问题，需要使用一个不会冲突的算法，比如UUID，但是UUID占用空间大，索引效率低，生成ID太随机，没有可读性，并且不递增，无法排序。
Twitter的Snowflake算法，是一个分布式 ID 的生成算法。它的核心思想是，产生一个 long 型的 ID，其中：
- 41bits 作为毫秒数。大概可以用 69.7 年。
- 10bits 作为机器编号（5bits 是数据中心，5bits 的机器 ID），支持 1024 个实例。
- 12bits 作为毫秒内的序列号。一毫秒可以生成 4096 个序号。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/e9293eadf4b5e61c4a2123bd48f2de19_MD5.jpeg)

### 处理流程
先查后写：
- 收到请求 → 先查存储（数据库/缓存）有没有这个 ID。
- 如果有 → 说明处理过，直接返回之前结果。  
- 如果没有 → 处理请求，并存储 ID。
- ✅ 简单直观，但每次都要查，性能开销大。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/016e676510e64a36109042e19be8193c_MD5.jpeg)
直接写（推荐）：
- 收到请求 → 直接尝试往存储里插入这个 ID。
- 如果成功插入 → 表明是第一次执行，正常处理。
- 如果失败（主键冲突） → 表明已经处理过，直接返回结果。
- ✅ 更快，因为把“查 + 写”合并成一次原子操作。
- 在 MySQL 里可以用 `INSERT ... ON DUPLICATE KEY UPDATE`，或者唯一索引保证。
难点是存储成了单点瓶颈

### HTTP的幂等性
HTTP GET 方法用于获取资源，不应有副作用，所以是幂等的。
HTTP HEAD 和 GET 本质是一样的，区别在于 HEAD 不含有呈现数据，而仅仅是 HTTP 头信息，不应有副作用，也是幂等的。HEAD常常是用于探活使用。
HTTP OPTIONS 主要用于获取当前 URL 所支持的方法，所以也是幂等的。
HTTP DELETE 方法用于删除资源，有副作用，但它应该满足幂等性。
HTTP POST 方法用于创建资源，所对应的 URI 并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性。
HTTP PUT 方法用于创建或更新操作，所对应的 URI 是要创建或更新的资源本身，有副作用，它应该满足幂等性。

所以，对于 POST 的方式，很可能会出现多次提交的问题。一般的幂等性的设计如下：
- 首先，在表单中需要隐藏一个 token，这个 token 可以是前端生成的一个唯一的 ID。用于防止用户多次点击了表单提交按钮，而导致后端收到了多次请求，却不能分辨是否是重复的提交。这个 token 是表单的唯一标识。（这种情况其实是通过前端生成 ID 把 POST 变成了 PUT。）
- 然后，当用户点击提交后，后端会把用户提交的数据和这个 token 保存在数据库中。如果有重复提交，那么数据库中的 token 会做排它限制，从而做到幂等性。
- 当然，更为稳妥的做法是，后端成功后向前端返回 302 跳转，把用户的前端页跳转到 GET 请求，把刚刚 POST 的数据给展示出来。如果是 Web 上的最好还把之前的表单设置成过期，这样用户不能通过浏览器后退按钮来重新提交。这个模式又叫做 PRG 模式（Post/Redirect/Get）。

## 弹力设计篇之“服务的状态”
所谓“状态”，就是为了保留程序的一些数据或是上下文。

### 无状态的服务 Stateless
一直以来，无状态的服务都被当作分布式服务设计的最佳实践和铁律。因为无状态的服务对于扩展性和运维实在是太方便了。
基本上来说，无状态的服务和“函数式编程”的思维方式如出一辙。在函数式编程中，一个铁律是，函数是无状态的。
但是，现实世界是一定会有状态的。这些状态可能表现在如下的几个方面:
- 程序调用的结果
- 服务组合下的上下文
- 服务的配置
为了做出无状态的服务，我们通常需要把状态保存到其他的地方。不重要的存Redis，重要的存MySQL或Zookeeper，Etcd等HA的强一致性存储，或分布式文件系统。
于是，我们为了做成无状态的服务，会导致这些服务需要耦合第三方有状态的存储服务。一方面是有依赖，另一方面也增加了网络开销，导致服务的响应时间也会变慢。
第三方存储服务必须是高可用高拓展的方式。而且，为了减少网络开销，还需要在无状态的服务中增加缓存机制。而用户请求不一定一直在同一台机器，这会导致所有实例都会存储缓存。
这种“转移责任”的玩法也催生出了对分布式存储的强烈需求。因为数据层的scheme很多，所以做出一个通用的分布式存储系统很难。
这也是为什么无状态的服务需要依赖于像 ZooKeeper/Etcd 这样的高可用的有强一致的服务，或是依赖于底层的分布式文件系统（像开源的 Ceph 和 GlusterFS）。而现在分布式数据库也开始将服务和存储分离，也是为了让自己的系统更有弹力。

### 有状态的服务 Stateful
无状态服务在程序 Bug 上和水平扩展上有非常优秀的表现，但是其需要把状态存放在一个第三方存储上，增加了网络开销，而在服务内的缓存需要在所有的服务实例上都有（因为每次请求不会都落在同一个服务实例上），这是比较浪费资源的。
有状态服务的好处是：
- 数据本地化Data Locality；一方面状态和数据是本机保存，这方面不但有更低的延时，而且对于数据密集型的应用来说，这会更快。
- 更高的可用性和更强的一致性。CAP中的AC
因为对于有状态的服务，我们需要对于客户端传来的请求，都必须保证其落在同一个实例上，这叫 Sticky Session 或是 Sticky Connection。
无状态的服务需要我们把数据同步到不同的节点上，而有状态的服务通过 Sticky Session 做数据分片（当然，同步有同步的问题，分片也有分片的问题，这两者没有谁比谁好，都有 trade-off）。



