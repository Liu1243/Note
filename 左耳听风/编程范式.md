## 起源
- 第一部分：泛型编程，第 1~3 章，讨论了从 C 到 C++ 的泛型编程方法，并系统地总结了编程语言中的类型系统和泛型编程的本质。
- 第二部分：函数式编程，第 4 章和第 5 章，讲述了函数式编程用到的技术，及其思维方式，并通过 Python 和 Go 修饰器的例子，展示了函数式编程下的代码扩展能力，以及函数的相互和随意拼装带来的好处。
- 第三部分：面向对象编程，第 6~8 章，讲述与传统的编程思想的相反之处，面向对象设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，列举了面向对象编程的优缺点，基于原型的编程范式，以及 Go 语言的委托模式。
- 第四部分：编程本质和逻辑编程，第 9~11 章，先探讨了编程的本质：逻辑部分才是真正有意义的，控制部分只能影响逻辑部分的效率，然后结合 Prolog 语言介绍了逻辑编程范式，最后对程序世界里的编程范式进行了总结，对比了它们之间的不同。

## 泛型编程
对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？
我们来看看 C++ 是如何有效解决程序泛型问题的，我认为有三点:
- 通过类的方式来解决。让一个用户自定义的数据类型和内建的那些数据类型就很一致
- 通过模板达到类型和算法的妥协。模板很好地取代了 C 时代宏定义带来的问题。
- 通过虚函数和运行时类型识别。可以写出基于抽象接口的泛型。

通过以上，cpp就可以做到泛型编程。
正如前面说过的，一个良好的泛型编程需要解决如下几个泛型编程的问题：
==算法的泛型、类型的泛型、数据结构的泛型==

### CPP泛型编程的重要技术-迭代器
首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。
它需要重载一些操作符，比如：取值操作*、成员操作->、比较操作\==和!=，还有遍历操作++，等等。
然后，还要typedef一些类型，比如value_type，告诉我们容器内的数据的实际类型是什么样子。
还有一些，如begin()和end()的基本操作。
我们还可以看到其中有一个pointer \_ptr的内部指针来指向当前的数据（注意，pointer就是 T\*）。

### 需要更多的抽象
更高维度的抽象reduce，reduce比sum更加抽象
`T reduce (Iter start, Iter end, T init, Op op)`
reduce 这个函数就更通用了，具体要干什么样的事情呢？放在匿名函数里面，它会定义我，我只做一个 reduce。更抽象地来说，我就把一个数组，一个集合，变成一个值。怎么变成一个值呢？由这个函数来决定。

## 类型系统和泛型的本质
第一件事是编程语言中的类型问题。
第二件事是对真实世界中业务代码的抽象、重用和拼装。

### 类型系统
类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组值，具有特定的意义和目的。
编程语言有两种类型：内建类型和抽象类型。

程序语言的类型系统主要提供如下的功能：
	程序语言的安全性。
	利于编译器的优化。
	代码的可读性。
	抽象化。
类型带来的问题就是我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。

我们需要清楚地知道，无论哪种程序语言，都避免不了一个特定的类型系统。

每个系统都需要一个类型检查系统。
	静态类型检查是在编译器进行语义分析时进行的。如果一个语言强制实行类型规则（即通常只允许以不丢失信息为前提的自动类型转换），那么称此处理为强类型，反之称为弱类型。
	动态类型检查系统更多的是在运行时期做动态类型标记和相关检查。

类型是对底层内存布局的一个抽象，会让我们的代码要关注于这些非业务逻辑上的东西。
任何语言都有类型系统，只是动态类型语言在运行时做类型检查。动态语言的代码复杂度比较低，并可以更容易地关注业务，在某些场景下是对的，但有些情况下却并不见得。

### 泛型的本质
类型的本质：
	类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。
	不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。
要做到泛型，需要做到：
	标准化掉类型的内存分配、释放和访问。
	标准化掉类型的操作。
	标准化掉数据容器的操作。
	标准化掉类型上特有的操作。
泛型的本质是：
==屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。==

### 小结
编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注于业务逻辑代码。但是因为，编程语言作为机器代码和业务逻辑的粘合层，是在让程序员可以控制更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trade-off 的事。
C 语言偏向于让程序员可以控制更多的底层细节，而 Java 和 Python 则让程序员更多地关注业务功能的实现。而 C++ 则是两者都想要，导致语言在设计上非常复杂。

## 函数式编程
编程工作更多的是解决业务上的问题，而不是计算机的问题，我们需要更为贴近业务、更为抽象的语言，如典型的面向对象语言 C++ 和 Java 等。
如何做更为抽象的泛型呢？答案就是函数式编程（Functional Programming）。

对于函数式编程来说，它只关心定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的。
函数式编程的特点是：
- stateless：函数不维护任何状态
- immutable：输入数据不能动
	没有状态就没有伤害。
	并行执行无伤害。
	Copy-Paste 重构代码无伤害。
	函数的执行没有顺序上的问题。
函数式编程的好处是：
惰性求值；确定性

因为状态，在并行执行和 copy-paste 时引发 bug 的概率是非常高的，所以没有状态就没有伤害，就像没有依赖就没有伤害一样，并行执行无伤害，copy 代码无伤害，因为没有状态，代码怎样拷都行。

函数式编程的劣势是：
数据复制比较严重。

对于纯函数式（也就是完全没有状态的函数）的编程来说，各个语言支持的程度如下：
	完全纯函数式 Haskell
	容易写纯函数 F#, Ocaml, Clojure, Scala
	纯函数需要花点精力 C#, Java, JavaScript

### 函数式编程用到的技术
first class function（头等函数）：函数就像变量一样使用
tail recursion optimization（尾递归优化）：
map & reduce：函数式编程最常见的技术就是对一个集合做Map和Reduce操作；相比过程式编程代码更易读。
pipeline（管道）：将函数实例组成一个个action放在数组或列表中，数据就像pipeline顺序被函数操作
recursing（递归）：递归的精髓是描述问题，而这正是函数式编程的精髓。
currying（柯里化）：把一个接受多个参数的函数，转化为一系列只接受 **一个参数** 的函数。
higher order function（高阶函数）：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。

例子：
```python
def inc(x):
	def incx(y):
		return x+y
	return incx

inc2 = inc(2)
inc5 = inc(5)

print inc2(5) # 输出 7
print inc5(5) # 输出 10
```
可以用inc()函数来构造各种版本的 inc 函数，这个技术其实就是上面所说的 currying 技术

- 把函数当成变量来用，关注描述问题而不是怎么实现，这样可以让代码更易读。
- 因为函数返回里面的这个函数，所以函数关注的是表达式，关注的是描述这个问题，而不是怎么实现这个事情。

### Lisp语言
Scheme 语言（Lisp 的一个方言）。在 Scheme 里，所有的操作都是函数，包括加减乘除这样的东西。所以，一个表达式是这样的形式—— （函数名 参数 1 参数 1）
```scheme
(define (plus x y) (+ x y))
(define (times x y) (* x y))
(define (square x) (times x x))
```

### 函数式编程的思维方式
函数式编程关注的是：describe what to do, rather than how to do it。于是，我们把以前的过程式编程范式叫做 Imperative Programming – 指令式编程，而把函数式编程范式叫做 Declarative Programming – 声明式编程。

### 函数式语言的三件套
函数式语言有三套件，Map、Reduce 和 Filter。
map 和 reduce 不关心源输入数据，它们只是控制，并不是业务。控制是描述怎么干，而业务是描述要干什么。

### 函数式的pipeline模式
pipeline（管道）借鉴于 Unix Shell 的管道操作——把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。（管道绝对是一个伟大的发明，它的设计哲学就是 KISS – 让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。）
如果我们把这些函数比作微服务，那么管道这个事是在干什么呢？其实就是在做服务的编排。
使用 Map & Reduce，不要使用循环”（还记得吗？使用循环会让我们只能使用顺序型的数据结构）

### 小结
相对于计算机发展史，函数式编程是个非常古老的概念，它的核心思想是将运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做，因而被称为声明式编程。以 Stateless（无状态）和 Immutable（不可变）为主要特点，代码简洁，易于理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性——无论在什么场景下都会得到同样的结果。

## 修饰器模式
“Decorator 模式”，又叫“修饰器模式”，或是“装饰器模式”。
Python以及Java实现Decorator比较简单，但Go实现就很复杂。使用Decorator可以实现pipeline。
修饰器模式就是做下面几件事：
	表面上看，修饰器模式就是扩展现有的一个函数的功能，让它可以干一些其他的事，或是在现有的函数功能上再附加上一些别的功能。
	除了我们可以感受到函数式编程下的代码扩展能力，我们还能感受到函数的互相和随意拼装带来的好处。
	但是深入看一下，我们不难发现，Decorator 这个函数其实是可以修饰几乎所有的函数的。于是，这种可以通用于其它函数的编程方式，可以很容易地将一些非业务功能的、属于控制类型的代码给抽象出来（所谓的控制类型的代码就是像 for-loop，或是打日志，或是函数路由，或是求函数运行时间之类的非业务功能性的代码）。

## 面向对象编程
函数式编程总结起来就是把一些功能或逻辑代码通过函数拼装方式来组织的玩法。这其中涉及最多的是函数，也就是编程中的代码逻辑。但我们知道，代码中还是需要处理数据的，这些就是所谓的“状态”，函数式编程需要我们写出无状态的代码。
对于状态和数据的处理，我们有必要提一下“面向对象编程”（Object-oriented programming，OOP）这个编程范式了。我们知道，面向对象的编程有三大特性：封装、继承和多态。
面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。

23个经典设计模式，基本上都是说了两个面向对象的核心理念：
“Program to an ‘interface’, not an ‘implementation’.”
使用者不需要知道数据类型、结构、算法的细节。
使用者不需要知道实现细节，只需要知道提供的接口。
利于抽象、封装、动态绑定、多态。
符合面向对象的特质和理念。

“Favor ‘object composition’ over ‘class inheritance’.”
继承需要给子类暴露一些父类的设计和实现细节。
父类实现的改变会造成子类也需要改变。
我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法。
继承更多的应该是为了多态。

示例一：拼装对象
桥接模式 Bridge

实例二：拼装功能
策略模式

实例三：资源管理
代理模式。构造函数和析构函数，RAII（Resource Acquisition Is Initialization，资源获取就是初始化），把一些控制资源分配和释放的逻辑交给这些代理类，然后，只需要关注业务逻辑代码了。而且，在我们的业务逻辑代码中，减少了这些和业务逻辑不相关的程序控制的代码。

### IoC控制反转
让各个业务方来依赖于标准插件和工作流接口，反转控制，让它们来控制系统，依赖倒置，让它们来依赖标准。

总之是通过一种标准来让业务更加规范。

面向对象的优缺点：
优点：
	能和真实的世界交相辉映，符合人的直觉。
	面向对象和数据库模型设计类型，更多地关注对象间的模型设计。
	强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。
	根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。
	拥有大量非常优秀的设计原则和设计模式。
	S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……
缺点：
	代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。
	代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。
	因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。

## 基于原型的编程范式
基于原型（Prototype）的编程其实也是面向对象编程的一种方式。没有class类，直接使用对象，主流语言是JavaScript。
基于原型和面向对象的对比；
- 在基于类的编程当中，对象总共有两种类型。类定义了对象的基本布局和函数特性，而接口是“可以使用的”对象，它基于特定类的样式。在此模型中，类表现为行为和结构的集合，对所有接口来说这些类的行为和结构都是相同的。因而，区分规则首先是基于行为和结构，而后才是状态。
- 原型编程看起来提倡程序员关注一系列对象实例的行为，而之后才关心如何将这些对象划分到最近的使用方式相似的原型对象，而不是分成类。

很多基于原型的系统提倡运行时进行原型的修改。
- 在基于类的语言中，一个新的实例通过类构造器和构造器可选的参数来构造，结果实例由类选定的行为和布局创建模型。
- 在基于原型的系统中构造对象有两种方法，通过复制已有的对象或者通过扩展空对象创建。

### JavaScript的原型概念
面向对象里面要有个 Class。但是 JavaScript 觉得不是这样的，它就是要基于原型编程，就不要 Class，就直接在对象上改就行了，基于编程的修改，直接对类型进行修改。

JavaScript 的两个东西，一个是 __proto__，另一个是 prototype，这两个东西很容易混淆。这里说明一下：
	__proto__ 主要是安放在一个实际的对象中，用它来产生一个链接，一个原型链，用于寻找方法名或属性，等等。
	prototype 是用 new 来创建一个对象时构造 __proto__ 用的。它是构造函数的一个属性。

JavaScript的对象有两种表现形式：一种是Object，一种是Function。
__proto__ 是所有对象用于链接原型的一个指针，而 prototype 则是 Function 对象的属性，其主要是用来当需要new一个对象时让 __proto__ 指针所指向的地方。 对于超级对象 Function 而言， Function.__proto__ 就是 Function.prototype。
![](%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/attachments/af881ef364f3fb0865426c1115d117b5_MD5.jpeg)

### 小结
在使用委托的基于原型的语言中，运行时语言可以“仅仅通过序列的指针找到匹配”这样的方式来定位属性或者寻找正确的数据。所有这些创建行为、共享的行为需要的是委托指针。
不像是基于类的面向对象语言中类和接口的关系，原型和它的分支之间的关系并不要求子对象有相似的内存结构，因为如此，子对象可以继续修改而无需像基于类的系统那样整理结构。还有一个要提到的地方是，不仅仅是数据，方法也能被修改。因为这个原因，大多数基于原型的语言把数据和方法提作“slots”。
这种在对象里面直接修改的玩法，虽然这个特性可以带来运行时的灵活性，我们可以在运行时修改一个 prototype，给它增加甚至删除属性和方法。但是其带来了执行的不确定性，也有安全性的问题，而代码还变得不可预测，这有点黑科技的味道了。因为这些不像静态类型系统，没有一个不可变的契约对代码的确定性有保证，所以，需要使用者来自己保证。