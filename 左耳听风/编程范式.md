## 起源
- 第一部分：泛型编程，第 1~3 章，讨论了从 C 到 C++ 的泛型编程方法，并系统地总结了编程语言中的类型系统和泛型编程的本质。
- 第二部分：函数式编程，第 4 章和第 5 章，讲述了函数式编程用到的技术，及其思维方式，并通过 Python 和 Go 修饰器的例子，展示了函数式编程下的代码扩展能力，以及函数的相互和随意拼装带来的好处。
- 第三部分：面向对象编程，第 6~8 章，讲述与传统的编程思想的相反之处，面向对象设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，列举了面向对象编程的优缺点，基于原型的编程范式，以及 Go 语言的委托模式。
- 第四部分：编程本质和逻辑编程，第 9~11 章，先探讨了编程的本质：逻辑部分才是真正有意义的，控制部分只能影响逻辑部分的效率，然后结合 Prolog 语言介绍了逻辑编程范式，最后对程序世界里的编程范式进行了总结，对比了它们之间的不同。

## 泛型编程
对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？
我们来看看 C++ 是如何有效解决程序泛型问题的，我认为有三点:
- 通过类的方式来解决。让一个用户自定义的数据类型和内建的那些数据类型就很一致
- 通过模板达到类型和算法的妥协。模板很好地取代了 C 时代宏定义带来的问题。
- 通过虚函数和运行时类型识别。可以写出基于抽象接口的泛型。

通过以上，cpp就可以做到泛型编程。
正如前面说过的，一个良好的泛型编程需要解决如下几个泛型编程的问题：
==算法的泛型、类型的泛型、数据结构的泛型==

### CPP泛型编程的重要技术-迭代器
首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。
它需要重载一些操作符，比如：取值操作*、成员操作->、比较操作\==和!=，还有遍历操作++，等等。
然后，还要typedef一些类型，比如value_type，告诉我们容器内的数据的实际类型是什么样子。
还有一些，如begin()和end()的基本操作。
我们还可以看到其中有一个pointer \_ptr的内部指针来指向当前的数据（注意，pointer就是 T\*）。

### 需要更多的抽象
更高维度的抽象reduce，reduce比sum更加抽象
`T reduce (Iter start, Iter end, T init, Op op)`
reduce 这个函数就更通用了，具体要干什么样的事情呢？放在匿名函数里面，它会定义我，我只做一个 reduce。更抽象地来说，我就把一个数组，一个集合，变成一个值。怎么变成一个值呢？由这个函数来决定。