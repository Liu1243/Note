参考： 
1. https://w0279g7ggv.feishu.cn/file/Js8Rb84SeoWjtpxLoPrc2yE0nhb
2. [# 能将三次握手理解到这个深度，面试官拍案叫绝！](https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247485862&idx=1&sn=1f3a92b8fd5fbc14c4d073d04c6d44ed&scene=21#wechat_redirect)

**目录**

- [1. socket到底是什么](#1.%20socket%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88)
	- [工作流程](#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B)
- [2. bind函数的作用](#2.%20bind%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8)
- [3. 服务器listen函数内部工作原理](#3.%20%E6%9C%8D%E5%8A%A1%E5%99%A8listen%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
- [4. 客户端connect函数工作原理](#4.%20%E5%AE%A2%E6%88%B7%E7%AB%AFconnect%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
- [5. 服务器响应SYN](#5.%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94SYN)
- [6. 客户端响应 SYNACK](#6.%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%93%8D%E5%BA%94%20SYNACK)
- [7. 服务器响应 ACK](#7.%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%20ACK)
- [8. 服务器accept](#8.%20%E6%9C%8D%E5%8A%A1%E5%99%A8accept)
- [9. 三次握手内核工作过程](#9.%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%86%85%E6%A0%B8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B)

## 1. socket到底是什么
客户端核心代码
>connect用于客户端发起与服务器的连接请求
``` cpp
int main() {
	fd = socket(AF_INET, SOCK_STREAM, 0);
	connect(fd, ...);
	...
}```
服务端核心代码
> bind将服务端的IP地址和端口号绑定到socket上
> listen将socket设置为监听状态，准备接受客户端的连接请求 
> accept从全连接队列中取出一个已经完成的连接，并返回一个新的socket描述符
``` cpp
int main() {
	int fd = socket(AF_INET, SOCK_STREAM, 0);
	bind(fd, ...);
	listen(fd, 128);
	accept(fd, ...);
	...
}
```
**Socket，即套接字，是计算机网络中用于实现进程间通信的一种机制**。它是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。
**Socket类型**：主要分为流式套接字（Stream Sockets，基于TCP协议）和数据报套接字（Datagram Sockets，基于UDP协议）。
### 工作流程

- **创建Socket**：应用程序通过调用`socket()`函数创建一个Socket对象，指定通信类型（TCP或UDP）。
- **绑定地址和端口**：服务器端将Socket绑定到特定的IP地址和端口号，以便客户端可以找到并连接。
- **监听连接**：服务器端通过`listen()`函数开始监听客户端的连接请求。
- **建立连接**：客户端通过`connect()`函数向服务器端发起连接请求，服务器端通过`accept()`函数接受请求，建立连接。
- **数据传输**：双方通过`send()`和`recv()`函数发送和接收数据。
- **关闭连接**：通信完成后，通过`close()`函数关闭Socket，释放资源。
## 2. bind函数的作用
``` cpp
int main() {
	int fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	struct sockaddr_in addr;
	addr.sin_famil = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sinport = ...;

	// 绑定ip和端口
	bind(fd, addr, ...);

	// 监听
	listen(fd, ...);
}
```
以下是客户端connect到服务端监听的socket上的图示
![[开发内功/网络管理/attachments/57c0488e3484b43a92aa564982062f2a_MD5.jpeg]]
![[开发内功/网络管理/attachments/0984d124ef65c65ee12668bc0910a3d5_MD5.jpeg]]
bind的源码流程如上，包括：
>1. 将要绑定的ip地址设置到了socket的`inet->inet_rcv_saddr`成员上
>2. 将要绑定的端口设置到了socket的`inet->inet_sport`成员上
## 3. 服务器listen函数内部工作原理
![](%E5%BC%80%E5%8F%91%E5%86%85%E5%8A%9F/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/attachments/dcf43327b1f6a42dafb1c28e76e460cd_MD5.jpeg)
首先内核计算半连接队列的长度。然后据此算出半连接队列所需要的实际内存大小，开始申请用于管理半连接队列对象的内存（半连接队列需要快速查找，所以内核是用哈希表来管理半连接队列的，具体在 listen_sock 下的 syn_table 下）。最后将半连接队列挂到了接收队列 queue 上。
另外 queue->rskq_accept_head 代表的是全连接队列，它是一个链表的形式。
当全连接队列和半连接队列中有元素的时候，他们在内核中的结构图大致如下。
![](%E5%BC%80%E5%8F%91%E5%86%85%E5%8A%9F/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/attachments/f316fd25eab17ecba5dfe691295667fa_MD5.jpeg)
**在服务器 listen 的时候，主要是进行了全/半连接队列的长度限制计算，以及相关的内存申请和初始化**。全/连接队列初始化了以后才可以相应来自客户端的握手请求。
>SYN攻击的原理就是让服务端管理半连接队列的哈希表爆满，使其无法处理正常用户的请求。
## 4. 客户端connect函数工作原理
![](%E5%BC%80%E5%8F%91%E5%86%85%E5%8A%9F/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/attachments/d3d80ae4e602038578415e7cf724ae76_MD5.jpeg)
客户端在发起connect调用时会先把 socket 状态设置为 TCP_SYN_SENT，再通过 inet_hash_connect 来动态地选择一个可用的端口。
![](%E5%BC%80%E5%8F%91%E5%86%85%E5%8A%9F/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/attachments/00471c4352a86fa5219430cc37f0e73c_MD5.jpeg)
`inet_get_local_port_range`函数会读取`net.ipv4.ip_local_port_range`这个内核参数，默认是32768-61000
选择完端口后，会进入到 tcp_connect 中申请和构造 SYN 包，然后将其发出。同时还启动了一个重传定时器，该定时器的作用是等到一定时间后收不到服务器的反馈的时候来开启重传。在 3.10 版本中首次超时时间是 1 s，一些老版本中是 3 s。
**总结一下，客户端在 connect 的时候，把本地 socket 状态设置成了 TCP_SYN_SENT，选了一个可用的端口，接着发出 SYN 握手请求并启动重传定时器**。
>还有一个问题就是客户端的端口号是否只能用一次？答案是否。
>内核在判断的时候是通过四元组进行判断的，`(源ip, 源port, 目的ip, 目的port)`，只要其余三个不一致端口就可以复用。

## 5. 服务器响应SYN
在服务器端，所有的 TCP 包（包括客户端发来的 SYN 握手请求）都经过网卡、软中断，进入到 tcp_v4_rcv。在该函数中根据网络包（skb）TCP 头信息中的目的 IP 信息查到当前在 listen 的 socket。然后继续进入 tcp_v4_do_rcv 处理握手过程。
``` cpp
//file: net/ipv4/tcp_ipv4.c  
int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)  
{  
 ...  
 //服务器收到第一步握手 SYN 或者第三步 ACK 都会走到这里  
 if (sk->sk_state == TCP_LISTEN) {  
  struct sock *nsk = tcp_v4_hnd_req(sk, skb);  
 }  
  
 if (tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb->len)) {  
  rsk = sk;  
  goto reset;  
 }  
}
```
在 tcp_v4_do_rcv 中判断当前 socket 是 listen 状态后，首先会到 tcp_v4_hnd_req 去查看半连接队列。服务器第一次响应 SYN 的时候，半连接队列里必然是空空如也，所以相当于什么也没干就返回了。
``` cpp
//file:net/ipv4/tcp_ipv4.c  
static struct sock *tcp_v4_hnd_req(struct sock *sk, struct sk_buff *skb)  
{  
 // 查找 listen socket 的半连接队列  
 struct request_sock *req = inet_csk_search_req(sk, &prev, th->source,  
          iph->saddr, iph->daddr);  
 ...  
 return sk;  
}
```
在 tcp_rcv_state_process 里根据不同的 socket 状态进行不同的处理。
``` cpp
//file:net/ipv4/tcp_input.c  
int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,  
     const struct tcphdr *th, unsigned int len)  
{  
 switch (sk->sk_state) {  
  //第一次握手  
  case TCP_LISTEN:  
   if (th->syn) { //判断是 SYN 握手包  
    ...  
    if (icsk->icsk_af_ops->conn_request(sk, skb) < 0)  
     return 1;  
 ......  
}
```
其中 conn_request 是一个函数指针，指向 tcp_v4_conn_request。**服务器响应 SYN 的主要处理逻辑都在这个 tcp_v4_conn_request 里**。
``` cpp
//file: net/ipv4/tcp_ipv4.c  
int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)  
{  
 //看看半连接队列是否满了  
 if (inet_csk_reqsk_queue_is_full(sk) && !isn) {  
  want_cookie = tcp_syn_flood_action(sk, skb, "TCP");  
  if (!want_cookie)  
   goto drop;  
 }  
  
 //在全连接队列满的情况下，如果有 young_ack，那么直接丢  
 if (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) > 1) {  
  NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);  
  goto drop;  
 }  
 ...  
 //分配 request_sock 内核对象  
 req = inet_reqsk_alloc(&tcp_request_sock_ops);  
  
 //构造 syn+ack 包  
 skb_synack = tcp_make_synack(sk, dst, req,  
  fastopen_cookie_present(&valid_foc) ? &valid_foc : NULL);  
  
 if (likely(!do_fastopen)) {  
  //发送 syn + ack 响应  
  err = ip_build_and_send_pkt(skb_synack, sk, ireq->loc_addr,  
    ireq->rmt_addr, ireq->opt);  
  
  //添加到半连接队列，并开启计时器  
  inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);  
 }else ...  
}
```
在这里首先判断半连接队列是否满了，如果满了的话进入 tcp_syn_flood_action 去判断是否开启了 tcp_syncookies 内核参数。**如果队列满，且未开启 tcp_syncookies，那么该握手包将直接被丢弃！！**
接着还要判断全连接队列是否满。因为全连接队列满也会导致握手异常的，那干脆就在第一次握手的时候也判断了。**如果全连接队列满了，且有 young_ack 的话，那么同样也是直接丢弃。**
>young_ack 是半连接队列里保持着的一个计数器。记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK，同时也没有完成过三次握手的sock数量

接下来是构造 synack 包，然后通过 ip_build_and_send_pkt 把它发送出去。
最后把当前握手信息添加到半连接队列，并开启计时器。计时器的作用是如果某个时间之内还收不到客户端的第三次握手的话，服务器会重传 synack 包。
**总结一下，服务器响应 ack 是主要工作是判断下接收队列是否满了，满的话可能会丢弃该请求，否则发出 synack。申请 request_sock 添加到半连接队列中，同时启动定时器**。
## 6. 客户端响应 SYNACK
客户端收到服务器端发来的 synack 包的时候，也会进入到 tcp_rcv_state_process 函数中来。不过由于自身 socket 的状态是 TCP_SYN_SENT，所以会进入到另一个不同的分支中去。
``` cpp
//file:net/ipv4/tcp_input.c  
//除了 ESTABLISHED 和 TIME_WAIT，其他状态下的 TCP 处理都走这里  
int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,  
     const struct tcphdr *th, unsigned int len)  
{  
 switch (sk->sk_state) {  
  //服务器收到第一个ACK包  
  case TCP_LISTEN:  
   ...  
  //客户端第二次握手处理   
  case TCP_SYN_SENT:  
   //处理 synack 包  
   queued = tcp_rcv_synsent_state_process(sk, skb, th, len);  
   ...  
   return 0;  
}
```
tcp_rcv_synsent_state_process 是客户端响应 synack 的主要逻辑。
总结来说，就是**客户端响应来自服务器端的 synack 时清除了 connect 时设置的重传定时器，把当前 socket 状态设置为 ESTABLISHED，开启保活计时器后发出第三次握手的 ack 确认。**
## 7. 服务器响应 ACK
服务器响应第三次握手的 ack 时同样会进入到 tcp_v4_do_rcv
``` cpp
//file: net/ipv4/tcp_ipv4.c  
int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)  
{  
 ...  
 if (sk->sk_state == TCP_LISTEN) {  
  struct sock *nsk = tcp_v4_hnd_req(sk, skb);  
 }  
  
 if (tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb->len)) {  
  rsk = sk;  
  goto reset;  
 }  
}
```
不过由于这已经是第三次握手了，半连接队列里会存在上次第一次握手时留下的半连接信息。所以 tcp_v4_hnd_req 的执行逻辑会不太一样。
总之，**服务器响应第三次握手 ack 所做的工作是把当前半连接对象删除，创建了新的 sock 后加入到全连接队列中，最后将新连接状态设置为 ESTABLISHED**。
## 8. 服务器accept
``` cpp
//file: net/ipv4/inet_connection_sock.c  
struct sock *inet_csk_accept(struct sock *sk, int flags, int *err)  
{  
 //从全连接队列中获取  
 struct request_sock_queue *queue = &icsk->icsk_accept_queue;  
 req = reqsk_queue_remove(queue);  
  
 newsk = req->sk;  
 return newsk;  
}
```
reqsk_queue_remove 这个操作很简单，就是从全连接队列的链表里获取出第一个元素返回就行了。
**所以，accept 的重点工作就是从已经建立好的全连接队列中取出一个返回给用户进程。**
## 9. 三次握手内核工作过程
![](%E5%BC%80%E5%8F%91%E5%86%85%E5%8A%9F/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/attachments/a87d5e4dee4f96d090e91d8c1de235f0_MD5.jpeg)
- 1. 服务器 listen 时，计算了全/半连接队列的长度，还申请了相关内存并初始化。
- 2. 客户端 connect 时，把本地 socket 状态设置成了 TCP_SYN_SENT，选则一个可用的端口，发出 SYN 握手请求并启动重传定时器。
- 3. 服务器响应 ack 时，会判断下接收队列是否满了，满的话可能会丢弃该请求。否则发出 synack，申请 request_sock 添加到半连接队列中，同时启动定时器。
- 4. 客户端响应 synack 时，清除了 connect 时设置的重传定时器，把当前 socket 状态设置为 ESTABLISHED，开启保活计时器后发出第三次握手的 ack 确认。
- 5. 服务器响应 ack 时，把对应半连接对象删除，创建了新的 sock 后加入到全连接队列中，最后将新连接状态设置为 ESTABLISHED。
- 6. accept 从已经建立好的全连接队列中取出一个返回给用户进程。
如果你的线上接口正常都是几十毫秒内返回，但偶尔出现了 1 s、或者 3 s 等这种偶发的响应耗时变长的问题，那么你就要去定位一下看看是不是出现了握手包的超时重传了。