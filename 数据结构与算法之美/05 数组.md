## 05 数组
### 低效的“插入”和“删除”
数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。
如果数组中存储的数据无序，可以直接将第k位元素搬到最后，然后将新元素放入第k个位置。
同样的，如果不追求数组的连续性，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。
这就是JVM标记清除垃圾回收算法的核心思想。

### 容器能否完全替代数组？
1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
3. 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object\[]\[] array；而用容器的话则需要这样定义：ArrayList\<ArrayList\<object> > array。
对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

## 06 链表
经典的链表应用场景，那就是 LRU 缓存淘汰算法。
除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。
这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。Java中LinkedHashMap的底层就是双向链表。

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。
如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

基于链表实现LRU缓存淘汰算法：
维护一个有序单链表，越靠近尾部的结点就是越早之前访问的。
1. 如果此数据之前已经存在链表，将从原来位置删除，插入链表头部
2. 如果没有在链表中存：
	1. 缓存未满，直接插入头部
	2. 缓存已满，删除尾部结点，插入头部
时间复杂度O（n）。
优化思路是引入散列表，记录每个数据的位置，将缓存访问的时间复杂度降到O（1）

课后思考：
如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？
答案：
通过快慢指针+后半部分原地反转的方式。
首先通过快慢指针找到链表中点，然后反转链表后半部分，最后再判断链表起点和链表尾部的等值。

### 如何写出正确的链表代码
技巧三：利用哨兵简化实现难度
针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。
技巧四：重点留意边界条件处理
	如果链表为空时，代码是否能正常工作？
	如果链表只包含一个结点时，代码是否能正常工作？
	如果链表只包含两个结点时，代码是否能正常工作？
	代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
